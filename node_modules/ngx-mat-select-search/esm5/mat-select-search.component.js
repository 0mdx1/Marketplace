/**
 * Copyright (c) 2018 Bithost GmbH All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
import * as tslib_1 from "tslib";
import { ChangeDetectionStrategy, ChangeDetectorRef, Component, ContentChild, ElementRef, EventEmitter, forwardRef, HostBinding, Inject, Input, OnDestroy, OnInit, Optional, Output, QueryList, ViewChild } from '@angular/core';
import { FormControl, NG_VALUE_ACCESSOR } from '@angular/forms';
import { _countGroupLabelsBeforeOption, MatOption } from '@angular/material/core';
import { MatSelect } from '@angular/material/select';
import { MatFormField } from '@angular/material/form-field';
import { A, DOWN_ARROW, END, ENTER, ESCAPE, HOME, NINE, SPACE, UP_ARROW, Z, ZERO, } from '@angular/cdk/keycodes';
import { ViewportRuler } from '@angular/cdk/scrolling';
import { LiveAnnouncer } from '@angular/cdk/a11y';
import { BehaviorSubject, combineLatest, of, Subject } from 'rxjs';
import { delay, filter, map, startWith, switchMap, take, takeUntil, tap } from 'rxjs/operators';
import { MatSelectSearchClearDirective } from './mat-select-search-clear.directive';
/** The max height of the select's overlay panel. */
var SELECT_PANEL_MAX_HEIGHT = 256;
/* tslint:disable:member-ordering component-selector */
/**
 * Component providing an input field for searching MatSelect options.
 *
 * Example usage:
 *
 * interface Bank {
 *  id: string;
 *  name: string;
 * }
 *
 * @Component({
 *   selector: 'my-app-data-selection',
 *   template: `
 *     <mat-form-field>
 *       <mat-select [formControl]="bankCtrl" placeholder="Bank">
 *         <mat-option>
 *           <ngx-mat-select-search [formControl]="bankFilterCtrl"></ngx-mat-select-search>
 *         </mat-option>
 *         <mat-option *ngFor="let bank of filteredBanks | async" [value]="bank.id">
 *           {{bank.name}}
 *         </mat-option>
 *       </mat-select>
 *     </mat-form-field>
 *   `
 * })
 * export class DataSelectionComponent implements OnInit, OnDestroy {
 *
 *   // control for the selected bank
 *   public bankCtrl: FormControl = new FormControl();
 *   // control for the MatSelect filter keyword
 *   public bankFilterCtrl: FormControl = new FormControl();
 *
 *   // list of banks
 *   private banks: Bank[] = [{name: 'Bank A', id: 'A'}, {name: 'Bank B', id: 'B'}, {name: 'Bank C', id: 'C'}];
 *   // list of banks filtered by search keyword
 *   public filteredBanks: ReplaySubject<Bank[]> = new ReplaySubject<Bank[]>(1);
 *
 *   // Subject that emits when the component has been destroyed.
 *   private _onDestroy = new Subject<void>();
 *
 *
 *   ngOnInit() {
 *     // load the initial bank list
 *     this.filteredBanks.next(this.banks.slice());
 *     // listen for search field value changes
 *     this.bankFilterCtrl.valueChanges
 *       .pipe(takeUntil(this._onDestroy))
 *       .subscribe(() => {
 *         this.filterBanks();
 *       });
 *   }
 *
 *   ngOnDestroy() {
 *     this._onDestroy.next();
 *     this._onDestroy.complete();
 *   }
 *
 *   private filterBanks() {
 *     if (!this.banks) {
 *       return;
 *     }
 *
 *     // get the search keyword
 *     let search = this.bankFilterCtrl.value;
 *     if (!search) {
 *       this.filteredBanks.next(this.banks.slice());
 *       return;
 *     } else {
 *       search = search.toLowerCase();
 *     }
 *
 *     // filter the banks
 *     this.filteredBanks.next(
 *       this.banks.filter(bank => bank.name.toLowerCase().indexOf(search) > -1)
 *     );
 *   }
 * }
 */
var MatSelectSearchComponent = /** @class */ (function () {
    function MatSelectSearchComponent(matSelect, changeDetectorRef, _viewportRuler, matOption, liveAnnouncer, matFormField) {
        var _this = this;
        if (matOption === void 0) { matOption = null; }
        if (matFormField === void 0) { matFormField = null; }
        this.matSelect = matSelect;
        this.changeDetectorRef = changeDetectorRef;
        this._viewportRuler = _viewportRuler;
        this.matOption = matOption;
        this.liveAnnouncer = liveAnnouncer;
        this.matFormField = matFormField;
        /** Label of the search placeholder */
        this.placeholderLabel = 'Suche';
        /** Type of the search input field */
        this.type = 'text';
        /** Label to be shown when no entries are found. Set to null if no message should be shown. */
        this.noEntriesFoundLabel = 'Keine Optionen gefunden';
        /**
         *  Text that is appended to the currently active item label announced by screen readers,
         *  informing the user of the current index, value and total options.
         *  eg: Bank R (Germany) 1 of 6
        */
        this.indexAndLengthScreenReaderText = ' of ';
        /**
          * Whether or not the search field should be cleared after the dropdown menu is closed.
          * Useful for server-side filtering. See [#3](https://github.com/bithost-gmbh/ngx-mat-select-search/issues/3)
          */
        this.clearSearchInput = true;
        /** Whether to show the search-in-progress indicator */
        this.searching = false;
        /** Disables initial focusing of the input field */
        this.disableInitialFocus = false;
        /** Enable clear input on escape pressed */
        this.enableClearOnEscapePressed = false;
        /**
         * Prevents home / end key being propagated to mat-select,
         * allowing to move the cursor within the search input instead of navigating the options
         */
        this.preventHomeEndKeyPropagation = false;
        /** Disables scrolling to active options when option list changes. Useful for server-side search */
        this.disableScrollToActiveOnOptionsChanged = false;
        /** Adds 508 screen reader support for search box */
        this.ariaLabel = 'dropdown search';
        /** Whether to show Select All Checkbox (for mat-select[multi=true]) */
        this.showToggleAllCheckbox = false;
        /** select all checkbox checked state */
        this.toggleAllCheckboxChecked = false;
        /** select all checkbox indeterminate state */
        this.toggleAllCheckboxIndeterminate = false;
        /** Display a message in a tooltip on the toggle-all checkbox */
        this.toggleAllCheckboxTooltipMessage = '';
        /** Define the position of the tooltip on the toggle-all checkbox. */
        this.toogleAllCheckboxTooltipPosition = 'below';
        /** Show/Hide the search clear button of the search input */
        this.hideClearSearchButton = false;
        /**
         * Always restore selected options on selectionChange for mode multi (e.g. for lazy loading/infinity scrolling).
         * Defaults to false, so selected options are only restored while filtering is active.
         */
        this.alwaysRestoreSelectedOptionsMulti = false;
        /** Output emitter to send to parent component with the toggle all boolean */
        this.toggleAll = new EventEmitter();
        this.onTouched = function (_) { };
        this._options$ = new BehaviorSubject(null);
        this.optionsList$ = this._options$.pipe(switchMap(function (_options) { return _options ?
            _options.changes.pipe(map(function (options) { return options.toArray(); }), startWith(_options.toArray())) : of(null); }));
        this.optionsLength$ = this.optionsList$.pipe(map(function (options) { return options ? options.length : 0; }));
        this._formControl = new FormControl('');
        /** whether to show the no entries found message */
        this._showNoEntriesFound$ = combineLatest([
            this._formControl.valueChanges,
            this.optionsLength$
        ]).pipe(map(function (_a) {
            var _b = tslib_1.__read(_a, 2), value = _b[0], optionsLength = _b[1];
            return _this.noEntriesFoundLabel && value
                && optionsLength === _this.getOptionsLengthOffset();
        }));
        /** Subject that emits when the component has been destroyed. */
        this._onDestroy = new Subject();
    }
    MatSelectSearchComponent_1 = MatSelectSearchComponent;
    Object.defineProperty(MatSelectSearchComponent.prototype, "isInsideMatOption", {
        get: function () {
            return !!this.matOption;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MatSelectSearchComponent.prototype, "value", {
        /** Current search value */
        get: function () {
            return this._formControl.value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MatSelectSearchComponent.prototype, "_options", {
        get: function () {
            return this._options$.getValue();
        },
        /** Reference to the MatSelect options */
        set: function (_options) {
            this._options$.next(_options);
        },
        enumerable: true,
        configurable: true
    });
    MatSelectSearchComponent.prototype.ngOnInit = function () {
        var _this = this;
        // set custom panel class
        var panelClass = 'mat-select-search-panel';
        if (this.matSelect.panelClass) {
            if (Array.isArray(this.matSelect.panelClass)) {
                this.matSelect.panelClass.push(panelClass);
            }
            else if (typeof this.matSelect.panelClass === 'string') {
                this.matSelect.panelClass = [this.matSelect.panelClass, panelClass];
            }
            else if (typeof this.matSelect.panelClass === 'object') {
                this.matSelect.panelClass[panelClass] = true;
            }
        }
        else {
            this.matSelect.panelClass = panelClass;
        }
        // set custom mat-option class if the component was placed inside a mat-option
        if (this.matOption) {
            this.matOption.disabled = true;
            this.matOption._getHostElement().classList.add('contains-mat-select-search');
        }
        else {
            console.error('<ngx-mat-select-search> must be placed inside a <mat-option> element');
        }
        // when the select dropdown panel is opened or closed
        this.matSelect.openedChange
            .pipe(delay(1), takeUntil(this._onDestroy))
            .subscribe(function (opened) {
            if (opened) {
                _this.updateInputWidth();
                // focus the search field when opening
                if (!_this.disableInitialFocus) {
                    _this._focus();
                }
            }
            else {
                // clear it when closing
                if (_this.clearSearchInput) {
                    _this._reset();
                }
            }
        });
        // set the first item active after the options changed
        this.matSelect.openedChange
            .pipe(take(1))
            .pipe(takeUntil(this._onDestroy))
            .subscribe(function () {
            if (_this.matSelect._keyManager) {
                _this.matSelect._keyManager.change.pipe(takeUntil(_this._onDestroy))
                    .subscribe(function () { return _this.adjustScrollTopToFitActiveOptionIntoView(); });
            }
            else {
                console.log('_keyManager was not initialized.');
            }
            _this._options = _this.matSelect.options;
            // Closure variable for tracking the most recent first option.
            // In order to avoid avoid causing the list to
            // scroll to the top when options are added to the bottom of
            // the list (eg: infinite scroll), we compare only
            // the changes to the first options to determine if we
            // should set the first item as active.
            // This prevents unnecessary scrolling to the top of the list
            // when options are appended, but allows the first item
            // in the list to be set as active by default when there
            // is no active selection
            var previousFirstOption = _this._options.toArray()[_this.getOptionsLengthOffset()];
            _this._options.changes
                .pipe(takeUntil(_this._onDestroy))
                .subscribe(function () {
                // avoid "expression has been changed" error
                setTimeout(function () {
                    // Convert the QueryList to an array
                    var options = _this._options.toArray();
                    // The true first item is offset by 1
                    var currentFirstOption = options[_this.getOptionsLengthOffset()];
                    var keyManager = _this.matSelect._keyManager;
                    if (keyManager && _this.matSelect.panelOpen) {
                        // set first item active and input width
                        // Check to see if the first option in these changes is different from the previous.
                        var firstOptionIsChanged = !_this.matSelect.compareWith(previousFirstOption, currentFirstOption);
                        // CASE: The first option is different now.
                        // Indiciates we should set it as active and scroll to the top.
                        if (firstOptionIsChanged
                            || !keyManager.activeItem
                            || !options.find(function (option) { return _this.matSelect.compareWith(option, keyManager.activeItem); })) {
                            keyManager.setFirstItemActive();
                        }
                        // wait for panel width changes
                        setTimeout(function () {
                            _this.updateInputWidth();
                        });
                        if (!_this.disableScrollToActiveOnOptionsChanged) {
                            _this.adjustScrollTopToFitActiveOptionIntoView();
                        }
                    }
                    // Update our reference
                    previousFirstOption = currentFirstOption;
                });
            });
        });
        // add or remove css class depending on whether to show the no entries found message
        // note: this is hacky
        this._showNoEntriesFound$.pipe(takeUntil(this._onDestroy)).subscribe(function (showNoEntriesFound) {
            // set no entries found class on mat option
            if (_this.matOption) {
                if (showNoEntriesFound) {
                    _this.matOption._getHostElement().classList.add('mat-select-search-no-entries-found');
                }
                else {
                    _this.matOption._getHostElement().classList.remove('mat-select-search-no-entries-found');
                }
            }
        });
        // resize the input width when the viewport is resized, i.e. the trigger width could potentially be resized
        this._viewportRuler.change()
            .pipe(takeUntil(this._onDestroy))
            .subscribe(function () {
            if (_this.matSelect.panelOpen) {
                _this.updateInputWidth();
            }
        });
        this.initMultipleHandling();
        this.optionsList$.pipe(takeUntil(this._onDestroy)).subscribe(function () {
            // update view when available options change
            _this.changeDetectorRef.markForCheck();
        });
    };
    MatSelectSearchComponent.prototype._emitSelectAllBooleanToParent = function (state) {
        this.toggleAll.emit(state);
    };
    MatSelectSearchComponent.prototype.ngOnDestroy = function () {
        this._onDestroy.next();
        this._onDestroy.complete();
    };
    MatSelectSearchComponent.prototype._isToggleAllCheckboxVisible = function () {
        return this.matSelect.multiple && this.showToggleAllCheckbox;
    };
    /**
     * Handles the key down event with MatSelect.
     * Allows e.g. selecting with enter key, navigation with arrow keys, etc.
     * @param event
     */
    MatSelectSearchComponent.prototype._handleKeydown = function (event) {
        var _this = this;
        // Prevent propagation for all alphanumeric characters in order to avoid selection issues
        if ((event.key && event.key.length === 1) ||
            (event.keyCode >= A && event.keyCode <= Z) ||
            (event.keyCode >= ZERO && event.keyCode <= NINE) ||
            (event.keyCode === SPACE)
            || (this.preventHomeEndKeyPropagation && (event.keyCode === HOME || event.keyCode === END))) {
            event.stopPropagation();
        }
        if (this.matSelect.multiple && event.key && event.keyCode === ENTER) {
            // Regain focus after multiselect, so we can further type
            setTimeout(function () { return _this._focus(); });
        }
        // Special case if click Escape, if input is empty, close the dropdown, if not, empty out the search field
        if (this.enableClearOnEscapePressed === true && event.keyCode === ESCAPE && this.value) {
            this._reset(true);
            event.stopPropagation();
        }
    };
    /**
     * Handles the key up event with MatSelect.
     * Allows e.g. the announcing of the currently activeDescendant by screen readers.
     */
    MatSelectSearchComponent.prototype._handleKeyup = function (event) {
        if (event.keyCode === UP_ARROW || event.keyCode === DOWN_ARROW) {
            var ariaActiveDescendantId_1 = this.matSelect._getAriaActiveDescendant();
            var index = this._options.toArray().findIndex(function (item) { return item.id === ariaActiveDescendantId_1; });
            if (index !== -1) {
                var activeDescendant = this._options.toArray()[index];
                this.liveAnnouncer.announce(activeDescendant.viewValue + ' '
                    + this.getAriaIndex(index)
                    + this.indexAndLengthScreenReaderText
                    + this.getAriaLength());
            }
        }
    };
    /**
     * Calculate the index of the current option, taking the offset to length into account.
     * examples:
     *    Case 1 [Search, 1, 2, 3] will have offset of 1, due to search and will read index of total.
     *    Case 2 [1, 2, 3] will have offset of 0 and will read index +1 of total.
     */
    MatSelectSearchComponent.prototype.getAriaIndex = function (optionIndex) {
        if (this.getOptionsLengthOffset() === 0) {
            return optionIndex + 1;
        }
        return optionIndex;
    };
    /**
     * Calculate the length of the options, taking the offset to length into account.
     * examples:
     *    Case 1 [Search, 1, 2, 3] will have length of options.length -1, due to search.
     *    Case 2 [1, 2, 3] will have length of options.length.
     */
    MatSelectSearchComponent.prototype.getAriaLength = function () {
        return this._options.toArray().length - this.getOptionsLengthOffset();
    };
    MatSelectSearchComponent.prototype.writeValue = function (value) {
        this._lastExternalInputValue = value;
        this._formControl.setValue(value);
        this.changeDetectorRef.markForCheck();
    };
    MatSelectSearchComponent.prototype.onBlur = function () {
        this.onTouched();
    };
    MatSelectSearchComponent.prototype.registerOnChange = function (fn) {
        var _this = this;
        this._formControl.valueChanges.pipe(filter(function (value) { return value !== _this._lastExternalInputValue; }), tap(function () { return _this._lastExternalInputValue = undefined; }), takeUntil(this._onDestroy)).subscribe(fn);
    };
    MatSelectSearchComponent.prototype.registerOnTouched = function (fn) {
        this.onTouched = fn;
    };
    /**
     * Focuses the search input field
     */
    MatSelectSearchComponent.prototype._focus = function () {
        if (!this.searchSelectInput || !this.matSelect.panel) {
            return;
        }
        // save and restore scrollTop of panel, since it will be reset by focus()
        // note: this is hacky
        var panel = this.matSelect.panel.nativeElement;
        var scrollTop = panel.scrollTop;
        // focus
        this.searchSelectInput.nativeElement.focus();
        panel.scrollTop = scrollTop;
    };
    /**
     * Resets the current search value
     * @param focus whether to focus after resetting
     */
    MatSelectSearchComponent.prototype._reset = function (focus) {
        this._formControl.setValue('');
        if (focus) {
            this._focus();
        }
    };
    /**
     * Initializes handling <mat-select [multiple]="true">
     * Note: to improve this code, mat-select should be extended to allow disabling resetting the selection while filtering.
     */
    MatSelectSearchComponent.prototype.initMultipleHandling = function () {
        var _this = this;
        if (!this.matSelect.ngControl) {
            if (this.matSelect.multiple) {
                // note: the access to matSelect.ngControl (instead of matSelect.value / matSelect.valueChanges)
                // is necessary to properly work in multi-selection mode.
                console.error('the mat-select containing ngx-mat-select-search must have a ngModel or formControl directive when multiple=true');
            }
            return;
        }
        // if <mat-select [multiple]="true">
        // store previously selected values and restore them when they are deselected
        // because the option is not available while we are currently filtering
        this.previousSelectedValues = this.matSelect.ngControl.value;
        this.matSelect.ngControl.valueChanges
            .pipe(takeUntil(this._onDestroy))
            .subscribe(function (values) {
            var restoreSelectedValues = false;
            if (_this.matSelect.multiple) {
                if ((_this.alwaysRestoreSelectedOptionsMulti || (_this._formControl.value && _this._formControl.value.length))
                    && _this.previousSelectedValues && Array.isArray(_this.previousSelectedValues)) {
                    if (!values || !Array.isArray(values)) {
                        values = [];
                    }
                    var optionValues_1 = _this.matSelect.options.map(function (option) { return option.value; });
                    _this.previousSelectedValues.forEach(function (previousValue) {
                        if (!values.some(function (v) { return _this.matSelect.compareWith(v, previousValue); })
                            && !optionValues_1.some(function (v) { return _this.matSelect.compareWith(v, previousValue); })) {
                            // if a value that was selected before is deselected and not found in the options, it was deselected
                            // due to the filtering, so we restore it.
                            values.push(previousValue);
                            restoreSelectedValues = true;
                        }
                    });
                }
            }
            _this.previousSelectedValues = values;
            if (restoreSelectedValues) {
                _this.matSelect._onChange(values);
            }
        });
    };
    /**
     * Scrolls the currently active option into the view if it is not yet visible.
     */
    MatSelectSearchComponent.prototype.adjustScrollTopToFitActiveOptionIntoView = function () {
        if (this.matSelect.panel && this.matSelect.options.length > 0) {
            var matOptionHeight = this.getMatOptionHeight();
            var activeOptionIndex = this.matSelect._keyManager.activeItemIndex || 0;
            var labelCount = _countGroupLabelsBeforeOption(activeOptionIndex, this.matSelect.options, this.matSelect.optionGroups);
            // If the component is in a MatOption, the activeItemIndex will be offset by one.
            var indexOfOptionToFitIntoView = (this.matOption ? -1 : 0) + labelCount + activeOptionIndex;
            var currentScrollTop = this.matSelect.panel.nativeElement.scrollTop;
            var searchInputHeight = this.innerSelectSearch.nativeElement.offsetHeight;
            var amountOfVisibleOptions = Math.floor((SELECT_PANEL_MAX_HEIGHT - searchInputHeight) / matOptionHeight);
            var indexOfFirstVisibleOption = Math.round((currentScrollTop + searchInputHeight) / matOptionHeight) - 1;
            if (indexOfFirstVisibleOption >= indexOfOptionToFitIntoView) {
                this.matSelect.panel.nativeElement.scrollTop = indexOfOptionToFitIntoView * matOptionHeight;
            }
            else if (indexOfFirstVisibleOption + amountOfVisibleOptions <= indexOfOptionToFitIntoView) {
                this.matSelect.panel.nativeElement.scrollTop = (indexOfOptionToFitIntoView + 1) * matOptionHeight
                    - (SELECT_PANEL_MAX_HEIGHT - searchInputHeight);
            }
        }
    };
    /**
     *  Set the width of the innerSelectSearch to fit even custom scrollbars
     *  And support all Operation Systems
     */
    MatSelectSearchComponent.prototype.updateInputWidth = function () {
        if (!this.innerSelectSearch || !this.innerSelectSearch.nativeElement) {
            return;
        }
        var element = this.innerSelectSearch.nativeElement;
        var panelElement;
        while (element = element.parentElement) {
            if (element.classList.contains('mat-select-panel')) {
                panelElement = element;
                break;
            }
        }
        if (panelElement) {
            this.innerSelectSearch.nativeElement.style.width = panelElement.clientWidth + 'px';
        }
    };
    MatSelectSearchComponent.prototype.getMatOptionHeight = function () {
        if (this.matSelect.options.length > 0) {
            return this.matSelect.options.first._getHostElement().getBoundingClientRect().height;
        }
        return 0;
    };
    /**
     * Determine the offset to length that can be caused by the optional matOption used as a search input.
     */
    MatSelectSearchComponent.prototype.getOptionsLengthOffset = function () {
        if (this.matOption) {
            return 1;
        }
        else {
            return 0;
        }
    };
    var MatSelectSearchComponent_1;
    MatSelectSearchComponent.ctorParameters = function () { return [
        { type: MatSelect, decorators: [{ type: Inject, args: [MatSelect,] }] },
        { type: ChangeDetectorRef },
        { type: ViewportRuler },
        { type: MatOption, decorators: [{ type: Optional }, { type: Inject, args: [MatOption,] }] },
        { type: LiveAnnouncer },
        { type: MatFormField, decorators: [{ type: Optional }, { type: Inject, args: [MatFormField,] }] }
    ]; };
    tslib_1.__decorate([
        Input()
    ], MatSelectSearchComponent.prototype, "placeholderLabel", void 0);
    tslib_1.__decorate([
        Input()
    ], MatSelectSearchComponent.prototype, "type", void 0);
    tslib_1.__decorate([
        Input()
    ], MatSelectSearchComponent.prototype, "noEntriesFoundLabel", void 0);
    tslib_1.__decorate([
        Input()
    ], MatSelectSearchComponent.prototype, "indexAndLengthScreenReaderText", void 0);
    tslib_1.__decorate([
        Input()
    ], MatSelectSearchComponent.prototype, "clearSearchInput", void 0);
    tslib_1.__decorate([
        Input()
    ], MatSelectSearchComponent.prototype, "searching", void 0);
    tslib_1.__decorate([
        Input()
    ], MatSelectSearchComponent.prototype, "disableInitialFocus", void 0);
    tslib_1.__decorate([
        Input()
    ], MatSelectSearchComponent.prototype, "enableClearOnEscapePressed", void 0);
    tslib_1.__decorate([
        Input()
    ], MatSelectSearchComponent.prototype, "preventHomeEndKeyPropagation", void 0);
    tslib_1.__decorate([
        Input()
    ], MatSelectSearchComponent.prototype, "disableScrollToActiveOnOptionsChanged", void 0);
    tslib_1.__decorate([
        Input()
    ], MatSelectSearchComponent.prototype, "ariaLabel", void 0);
    tslib_1.__decorate([
        Input()
    ], MatSelectSearchComponent.prototype, "showToggleAllCheckbox", void 0);
    tslib_1.__decorate([
        Input()
    ], MatSelectSearchComponent.prototype, "toggleAllCheckboxChecked", void 0);
    tslib_1.__decorate([
        Input()
    ], MatSelectSearchComponent.prototype, "toggleAllCheckboxIndeterminate", void 0);
    tslib_1.__decorate([
        Input()
    ], MatSelectSearchComponent.prototype, "toggleAllCheckboxTooltipMessage", void 0);
    tslib_1.__decorate([
        Input()
    ], MatSelectSearchComponent.prototype, "toogleAllCheckboxTooltipPosition", void 0);
    tslib_1.__decorate([
        Input()
    ], MatSelectSearchComponent.prototype, "hideClearSearchButton", void 0);
    tslib_1.__decorate([
        Input()
    ], MatSelectSearchComponent.prototype, "alwaysRestoreSelectedOptionsMulti", void 0);
    tslib_1.__decorate([
        Output()
    ], MatSelectSearchComponent.prototype, "toggleAll", void 0);
    tslib_1.__decorate([
        ViewChild('searchSelectInput', { read: ElementRef, static: true })
    ], MatSelectSearchComponent.prototype, "searchSelectInput", void 0);
    tslib_1.__decorate([
        ViewChild('innerSelectSearch', { read: ElementRef, static: true })
    ], MatSelectSearchComponent.prototype, "innerSelectSearch", void 0);
    tslib_1.__decorate([
        ContentChild(MatSelectSearchClearDirective, { static: false })
    ], MatSelectSearchComponent.prototype, "clearIcon", void 0);
    tslib_1.__decorate([
        HostBinding('class.mat-select-search-inside-mat-option')
    ], MatSelectSearchComponent.prototype, "isInsideMatOption", null);
    MatSelectSearchComponent = MatSelectSearchComponent_1 = tslib_1.__decorate([
        Component({
            selector: 'ngx-mat-select-search',
            template: "<!-- Placeholder to adjust vertical offset of the mat-option elements -->\n<input matInput class=\"mat-select-search-input mat-select-search-hidden\"/>\n\n<!-- Note: the  mat-datepicker-content mat-tab-header are needed to inherit the material theme colors, see PR #22 -->\n<div\n      #innerSelectSearch\n      class=\"mat-select-search-inner mat-typography mat-datepicker-content mat-tab-header\"\n      [ngClass]=\"{'mat-select-search-inner-multiple': matSelect.multiple, 'mat-select-search-inner-toggle-all': _isToggleAllCheckboxVisible() }\">\n\n  <mat-checkbox *ngIf=\"_isToggleAllCheckboxVisible()\"\n                [color]=\"matFormField?.color\"\n                class=\"mat-select-search-toggle-all-checkbox\"\n                [checked]=\"toggleAllCheckboxChecked\"\n                [indeterminate]=\"toggleAllCheckboxIndeterminate\"\n                [matTooltip]=\"toggleAllCheckboxTooltipMessage\"\n                matTooltipClass=\"ngx-mat-select-search-toggle-all-tooltip\"\n                [matTooltipPosition]=\"toogleAllCheckboxTooltipPosition\"\n                (change)=\"_emitSelectAllBooleanToParent($event.checked)\"\n  ></mat-checkbox>\n\n  <input class=\"mat-select-search-input mat-input-element\"\n         autocomplete=\"off\"\n         [type]=\"type\"\n         [formControl]=\"_formControl\"\n         #searchSelectInput\n         (keydown)=\"_handleKeydown($event)\"\n         (keyup)=\"_handleKeyup($event)\"\n         (blur)=\"onBlur()\"\n         [placeholder]=\"placeholderLabel\"\n         [attr.aria-label]=\"ariaLabel\"\n  />\n  <mat-spinner *ngIf=\"searching\"\n          class=\"mat-select-search-spinner\"\n          diameter=\"16\"></mat-spinner>\n\n  <button mat-button\n          *ngIf=\"!hideClearSearchButton && value && !searching\"\n          mat-icon-button\n          aria-label=\"Clear\"\n          (click)=\"_reset(true)\"\n          class=\"mat-select-search-clear\">\n    <ng-content *ngIf=\"clearIcon; else defaultIcon\" select=\"[ngxMatSelectSearchClear]\"></ng-content>\n    <ng-template #defaultIcon>\n      <mat-icon>close</mat-icon>\n    </ng-template>\n  </button>\n\n  <ng-content select=\".mat-select-search-custom-header-content\"></ng-content>\n\n</div>\n\n<div *ngIf=\"_showNoEntriesFound$ | async\"\n     class=\"mat-select-search-no-entries-found\">\n  {{noEntriesFoundLabel}}\n</div>\n<!--\nCopyright (c) 2018 Bithost GmbH All Rights Reserved.\n\nUse of this source code is governed by an MIT-style license that can be\nfound in the LICENSE file at https://angular.io/license\n-->\n",
            providers: [
                {
                    provide: NG_VALUE_ACCESSOR,
                    useExisting: forwardRef(function () { return MatSelectSearchComponent_1; }),
                    multi: true
                }
            ],
            changeDetection: ChangeDetectionStrategy.OnPush,
            styles: [".mat-select-search-hidden{visibility:hidden}.mat-select-search-inner{position:absolute;top:0;width:100%;border-bottom-width:1px;border-bottom-style:solid;z-index:100;font-size:inherit;box-shadow:none;border-radius:4px 4px 0 0;-webkit-transform:translate3d(0,0,0)}.mat-select-search-inner.mat-select-search-inner-multiple{width:100%}.mat-select-search-inner.mat-select-search-inner-multiple.mat-select-search-inner-toggle-all{display:flex;align-items:center}.mat-select-search-inner .mat-input-element{flex-basis:auto}.mat-select-search-inner .mat-input-element:-ms-input-placeholder{-ms-user-select:text}::ng-deep .mat-select-search-panel{transform:none!important;overflow-x:hidden}.mat-select-search-input{padding:16px 44px 16px 16px;box-sizing:border-box;width:100%}:host-context([dir=rtl]) .mat-select-search-input{padding-right:16px;padding-left:44px}.mat-select-search-no-entries-found{padding:16px}.mat-select-search-clear{position:absolute;right:4px;top:5px}:host-context([dir=rtl]) .mat-select-search-clear{right:auto;left:4px}.mat-select-search-spinner{position:absolute;right:16px;top:calc(50% - 8px)}:host-context([dir=rtl]) .mat-select-search-spinner{right:auto;left:16px}:host.mat-select-search-inside-mat-option .mat-select-search-input{padding-top:0;padding-bottom:0;height:3em;line-height:3em}:host.mat-select-search-inside-mat-option .mat-select-search-clear{top:3px}::ng-deep .mat-option[aria-disabled=true].contains-mat-select-search{position:static;padding:0}::ng-deep .mat-option[aria-disabled=true].contains-mat-select-search .mat-icon{margin-right:0;margin-left:0}::ng-deep .mat-option[aria-disabled=true].contains-mat-select-search .mat-option-pseudo-checkbox{display:none}::ng-deep .mat-option[aria-disabled=true].contains-mat-select-search.mat-select-search-no-entries-found{height:6em}.mat-select-search-toggle-all-checkbox{padding-left:16px;padding-bottom:2px}:host-context([dir=rtl]) .mat-select-search-toggle-all-checkbox{padding-left:0;padding-right:16px}"]
        }),
        tslib_1.__param(0, Inject(MatSelect)),
        tslib_1.__param(3, Optional()), tslib_1.__param(3, Inject(MatOption)),
        tslib_1.__param(5, Optional()), tslib_1.__param(5, Inject(MatFormField))
    ], MatSelectSearchComponent);
    return MatSelectSearchComponent;
}());
export { MatSelectSearchComponent };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibWF0LXNlbGVjdC1zZWFyY2guY29tcG9uZW50LmpzIiwic291cmNlUm9vdCI6Im5nOi8vbmd4LW1hdC1zZWxlY3Qtc2VhcmNoLyIsInNvdXJjZXMiOlsibWF0LXNlbGVjdC1zZWFyY2guY29tcG9uZW50LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOzs7OztHQUtHOztBQUVILE9BQU8sRUFDTCx1QkFBdUIsRUFDdkIsaUJBQWlCLEVBQ2pCLFNBQVMsRUFDVCxZQUFZLEVBQ1osVUFBVSxFQUNWLFlBQVksRUFDWixVQUFVLEVBQ1YsV0FBVyxFQUNYLE1BQU0sRUFDTixLQUFLLEVBQ0wsU0FBUyxFQUNULE1BQU0sRUFDTixRQUFRLEVBQ1IsTUFBTSxFQUNOLFNBQVMsRUFDVCxTQUFTLEVBQ1YsTUFBTSxlQUFlLENBQUM7QUFDdkIsT0FBTyxFQUF3QixXQUFXLEVBQUUsaUJBQWlCLEVBQUUsTUFBTSxnQkFBZ0IsQ0FBQztBQUN0RixPQUFPLEVBQUUsNkJBQTZCLEVBQUUsU0FBUyxFQUFFLE1BQU0sd0JBQXdCLENBQUM7QUFDbEYsT0FBTyxFQUFFLFNBQVMsRUFBRSxNQUFNLDBCQUEwQixDQUFDO0FBQ3JELE9BQU8sRUFBRSxZQUFZLEVBQUUsTUFBTSw4QkFBOEIsQ0FBQztBQUM1RCxPQUFPLEVBQUUsQ0FBQyxFQUFFLFVBQVUsRUFBRSxHQUFHLEVBQUUsS0FBSyxFQUFFLE1BQU0sRUFBRSxJQUFJLEVBQUUsSUFBSSxFQUFFLEtBQUssRUFBRSxRQUFRLEVBQUUsQ0FBQyxFQUFFLElBQUksR0FBRyxNQUFNLHVCQUF1QixDQUFDO0FBQ2pILE9BQU8sRUFBRSxhQUFhLEVBQUUsTUFBTSx3QkFBd0IsQ0FBQztBQUN2RCxPQUFPLEVBQUUsYUFBYSxFQUFFLE1BQU0sbUJBQW1CLENBQUM7QUFDbEQsT0FBTyxFQUFFLGVBQWUsRUFBRSxhQUFhLEVBQWMsRUFBRSxFQUFFLE9BQU8sRUFBRSxNQUFNLE1BQU0sQ0FBQztBQUMvRSxPQUFPLEVBQUUsS0FBSyxFQUFFLE1B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WSxDQUFDLENBQUE7T0EzSXhCLHdCQUF3QixDQWdpQnBDO0lBQUQsK0JBQUM7Q0FBQSxBQWhpQkQsSUFnaUJDO1NBaGlCWSx3QkFBd0IiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxOCBCaXRob3N0IEdtYkggQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG5cbmltcG9ydCB7XG4gIENoYW5nZURldGVjdGlvblN0cmF0ZWd5LFxuICBDaGFuZ2VEZXRlY3RvclJlZixcbiAgQ29tcG9uZW50LFxuICBDb250ZW50Q2hpbGQsXG4gIEVsZW1lbnRSZWYsXG4gIEV2ZW50RW1pdHRlcixcbiAgZm9yd2FyZFJlZixcbiAgSG9zdEJpbmRpbmcsXG4gIEluamVjdCxcbiAgSW5wdXQsXG4gIE9uRGVzdHJveSxcbiAgT25Jbml0LFxuICBPcHRpb25hbCxcbiAgT3V0cHV0LFxuICBRdWVyeUxpc3QsXG4gIFZpZXdDaGlsZFxufSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IENvbnRyb2xWYWx1ZUFjY2Vzc29yLCBGb3JtQ29udHJvbCwgTkdfVkFMVUVfQUNDRVNTT1IgfSBmcm9tICdAYW5ndWxhci9mb3Jtcyc7XG5pbXBvcnQgeyBfY291bnRHcm91cExhYmVsc0JlZm9yZU9wdGlvbiwgTWF0T3B0aW9uIH0gZnJvbSAnQGFuZ3VsYXIvbWF0ZXJpYWwvY29yZSc7XG5pbXBvcnQgeyBNYXRTZWxlY3QgfSBmcm9tICdAYW5ndWxhci9tYXRlcmlhbC9zZWxlY3QnO1xuaW1wb3J0IHsgTWF0Rm9ybUZpZWxkIH0gZnJvbSAnQGFuZ3VsYXIvbWF0ZXJpYWwvZm9ybS1maWVsZCc7XG5pbXBvcnQgeyBBLCBET1dOX0FSUk9XLCBFTkQsIEVOVEVSLCBFU0NBUEUsIEhPTUUsIE5JTkUsIFNQQUNFLCBVUF9BUlJPVywgWiwgWkVSTywgfSBmcm9tICdAYW5ndWxhci9jZGsva2V5Y29kZXMnO1xuaW1wb3J0IHsgVmlld3BvcnRSdWxlciB9IGZyb20gJ0Bhbmd1bGFyL2Nkay9zY3JvbGxpbmcnO1xuaW1wb3J0IHsgTGl2ZUFubm91bmNlciB9IGZyb20gJ0Bhbmd1bGFyL2Nkay9hMTF5JztcbmltcG9ydCB7IEJlaGF2aW9yU3ViamVjdCwgY29tYmluZUxhdGVzdCwgT2JzZXJ2YWJsZSwgb2YsIFN1YmplY3QgfSBmcm9tICdyeGpzJztcbmltcG9ydCB7IGRlbGF5LCBmaWx0ZXIsIG1hcCwgc3RhcnRXaXRoLCBzd2l0Y2hNYXAsIHRha2UsIHRha2VVbnRpbCwgdGFwIH0gZnJvbSAncnhqcy9vcGVyYXRvcnMnO1xuXG5pbXBvcnQgeyBNYXRTZWxlY3RTZWFyY2hDbGVhckRpcmVjdGl2ZSB9IGZyb20gJy4vbWF0LXNlbGVjdC1zZWFyY2gtY2xlYXIuZGlyZWN0aXZlJztcblxuLyoqIFRoZSBtYXggaGVpZ2h0IG9mIHRoZSBzZWxlY3QncyBvdmVybGF5IHBhbmVsLiAqL1xuY29uc3QgU0VMRUNUX1BBTkVMX01BWF9IRUlHSFQgPSAyNTY7XG5cbi8qIHRzbGludDpkaXNhYmxlOm1lbWJlci1vcmRlcmluZyBjb21wb25lbnQtc2VsZWN0b3IgKi9cbi8qKlxuICogQ29tcG9uZW50IHByb3ZpZGluZyBhbiBpbnB1dCBmaWVsZCBmb3Igc2VhcmNoaW5nIE1hdFNlbGVjdCBvcHRpb25zLlxuICpcbiAqIEV4YW1wbGUgdXNhZ2U6XG4gKlxuICogaW50ZXJmYWNlIEJhbmsge1xuICogIGlkOiBzdHJpbmc7XG4gKiAgbmFtZTogc3RyaW5nO1xuICogfVxuICpcbiAqIEBDb21wb25lbnQoe1xuICogICBzZWxlY3RvcjogJ215LWFwcC1kYXRhLXNlbGVjdGlvbicsXG4gKiAgIHRlbXBsYXRlOiBgXG4gKiAgICAgPG1hdC1mb3JtLWZpZWxkPlxuICogICAgICAgPG1hdC1zZWxlY3QgW2Zvcm1Db250cm9sXT1cImJhbmtDdHJsXCIgcGxhY2Vob2xkZXI9XCJCYW5rXCI+XG4gKiAgICAgICAgIDxtYXQtb3B0aW9uPlxuICogICAgICAgICAgIDxuZ3gtbWF0LXNlbGVjdC1zZWFyY2ggW2Zvcm1Db250cm9sXT1cImJhbmtGaWx0ZXJDdHJsXCI+PC9uZ3gtbWF0LXNlbGVjdC1zZWFyY2g+XG4gKiAgICAgICAgIDwvbWF0LW9wdGlvbj5cbiAqICAgICAgICAgPG1hdC1vcHRpb24gKm5nRm9yPVwibGV0IGJhbmsgb2YgZmlsdGVyZWRCYW5rcyB8IGFzeW5jXCIgW3ZhbHVlXT1cImJhbmsuaWRcIj5cbiAqICAgICAgICAgICB7e2JhbmsubmFtZX19XG4gKiAgICAgICAgIDwvbWF0LW9wdGlvbj5cbiAqICAgICAgIDwvbWF0LXNlbGVjdD5cbiAqICAgICA8L21hdC1mb3JtLWZpZWxkPlxuICogICBgXG4gKiB9KVxuICogZXhwb3J0IGNsYXNzIERhdGFTZWxlY3Rpb25Db21wb25lbnQgaW1wbGVtZW50cyBPbkluaXQsIE9uRGVzdHJveSB7XG4gKlxuICogICAvLyBjb250cm9sIGZvciB0aGUgc2VsZWN0ZWQgYmFua1xuICogICBwdWJsaWMgYmFua0N0cmw6IEZvcm1Db250cm9sID0gbmV3IEZvcm1Db250cm9sKCk7XG4gKiAgIC8vIGNvbnRyb2wgZm9yIHRoZSBNYXRTZWxlY3QgZmlsdGVyIGtleXdvcmRcbiAqICAgcHVibGljIGJhbmtGaWx0ZXJDdHJsOiBGb3JtQ29udHJvbCA9IG5ldyBGb3JtQ29udHJvbCgpO1xuICpcbiAqICAgLy8gbGlzdCBvZiBiYW5rc1xuICogICBwcml2YXRlIGJhbmtzOiBCYW5rW10gPSBbe25hbWU6ICdCYW5rIEEnLCBpZDogJ0EnfSwge25hbWU6ICdCYW5rIEInLCBpZDogJ0InfSwge25hbWU6ICdCYW5rIEMnLCBpZDogJ0MnfV07XG4gKiAgIC8vIGxpc3Qgb2YgYmFua3MgZmlsdGVyZWQgYnkgc2VhcmNoIGtleXdvcmRcbiAqICAgcHVibGljIGZpbHRlcmVkQmFua3M6IFJlcGxheVN1YmplY3Q8QmFua1tdPiA9IG5ldyBSZXBsYXlTdWJqZWN0PEJhbmtbXT4oMSk7XG4gKlxuICogICAvLyBTdWJqZWN0IHRoYXQgZW1pdHMgd2hlbiB0aGUgY29tcG9uZW50IGhhcyBiZWVuIGRlc3Ryb3llZC5cbiAqICAgcHJpdmF0ZSBfb25EZXN0cm95ID0gbmV3IFN1YmplY3Q8dm9pZD4oKTtcbiAqXG4gKlxuICogICBuZ09uSW5pdCgpIHtcbiAqICAgICAvLyBsb2FkIHRoZSBpbml0aWFsIGJhbmsgbGlzdFxuICogICAgIHRoaXMuZmlsdGVyZWRCYW5rcy5uZXh0KHRoaXMuYmFua3Muc2xpY2UoKSk7XG4gKiAgICAgLy8gbGlzdGVuIGZvciBzZWFyY2ggZmllbGQgdmFsdWUgY2hhbmdlc1xuICogICAgIHRoaXMuYmFua0ZpbHRlckN0cmwudmFsdWVDaGFuZ2VzXG4gKiAgICAgICAucGlwZSh0YWtlVW50aWwodGhpcy5fb25EZXN0cm95KSlcbiAqICAgICAgIC5zdWJzY3JpYmUoKCkgPT4ge1xuICogICAgICAgICB0aGlzLmZpbHRlckJhbmtzKCk7XG4gKiAgICAgICB9KTtcbiAqICAgfVxuICpcbiAqICAgbmdPbkRlc3Ryb3koKSB7XG4gKiAgICAgdGhpcy5fb25EZXN0cm95Lm5leHQoKTtcbiAqICAgICB0aGlzLl9vbkRlc3Ryb3kuY29tcGxldGUoKTtcbiAqICAgfVxuICpcbiAqICAgcHJpdmF0ZSBmaWx0ZXJCYW5rcygpIHtcbiAqICAgICBpZiAoIXRoaXMuYmFua3MpIHtcbiAqICAgICAgIHJldHVybjtcbiAqICAgICB9XG4gKlxuICogICAgIC8vIGdldCB0aGUgc2VhcmNoIGtleXdvcmRcbiAqICAgICBsZXQgc2VhcmNoID0gdGhpcy5iYW5rRmlsdGVyQ3RybC52YWx1ZTtcbiAqICAgICBpZiAoIXNlYXJjaCkge1xuICogICAgICAgdGhpcy5maWx0ZXJlZEJhbmtzLm5leHQodGhpcy5iYW5rcy5zbGljZSgpKTtcbiAqICAgICAgIHJldHVybjtcbiAqICAgICB9IGVsc2Uge1xuICogICAgICAgc2VhcmNoID0gc2VhcmNoLnRvTG93ZXJDYXNlKCk7XG4gKiAgICAgfVxuICpcbiAqICAgICAvLyBmaWx0ZXIgdGhlIGJhbmtzXG4gKiAgICAgdGhpcy5maWx0ZXJlZEJhbmtzLm5leHQoXG4gKiAgICAgICB0aGlzLmJhbmtzLmZpbHRlcihiYW5rID0+IGJhbmsubmFtZS50b0xvd2VyQ2FzZSgpLmluZGV4T2Yoc2VhcmNoKSA+IC0xKVxuICogICAgICk7XG4gKiAgIH1cbiAqIH1cbiAqL1xuQENvbXBvbmVudCh7XG4gIHNlbGVjdG9yOiAnbmd4LW1hdC1zZWxlY3Qtc2VhcmNoJyxcbiAgdGVtcGxhdGVVcmw6ICcuL21hdC1zZWxlY3Qtc2VhcmNoLmNvbXBvbmVudC5odG1sJyxcbiAgc3R5bGVVcmxzOiBbJy4vbWF0LXNlbGVjdC1zZWFyY2guY29tcG9uZW50LnNjc3MnXSxcbiAgcHJvdmlkZXJzOiBbXG4gICAge1xuICAgICAgcHJvdmlkZTogTkdfVkFMVUVfQUNDRVNTT1IsXG4gICAgICB1c2VFeGlzdGluZzogZm9yd2FyZFJlZigoKSA9PiBNYXRTZWxlY3RTZWFyY2hDb21wb25lbnQpLFxuICAgICAgbXVsdGk6IHRydWVcbiAgICB9XG4gIF0sXG4gIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoXG59KVxuZXhwb3J0IGNsYXNzIE1hdFNlbGVjdFNlYXJjaENvbXBvbmVudCBpbXBsZW1lbnRzIE9uSW5pdCwgT25EZXN0cm95LCBDb250cm9sVmFsdWVBY2Nlc3NvciB7XG5cbiAgLyoqIExhYmVsIG9mIHRoZSBzZWFyY2ggcGxhY2Vob2xkZXIgKi9cbiAgQElucHV0KCkgcGxhY2Vob2xkZXJMYWJlbCA9ICdTdWNoZSc7XG5cbiAgLyoqIFR5cGUgb2YgdGhlIHNlYXJjaCBpbnB1dCBmaWVsZCAqL1xuICBASW5wdXQoKSB0eXBlID0gJ3RleHQnO1xuXG4gIC8qKiBMYWJlbCB0byBiZSBzaG93biB3aGVuIG5vIGVudHJpZXMgYXJlIGZvdW5kLiBTZXQgdG8gbnVsbCBpZiBubyBtZXNzYWdlIHNob3VsZCBiZSBzaG93bi4gKi9cbiAgQElucHV0KCkgbm9FbnRyaWVzRm91bmRMYWJlbCA9ICdLZWluZSBPcHRpb25lbiBnZWZ1bmRlbic7XG5cbiAgLyoqXG4gICAqICBUZXh0IHRoYXQgaXMgYXBwZW5kZWQgdG8gdGhlIGN1cnJlbnRseSBhY3RpdmUgaXRlbSBsYWJlbCBhbm5vdW5jZWQgYnkgc2NyZWVuIHJlYWRlcnMsXG4gICAqICBpbmZvcm1pbmcgdGhlIHVzZXIgb2YgdGhlIGN1cnJlbnQgaW5kZXgsIHZhbHVlIGFuZCB0b3RhbCBvcHRpb25zLlxuICAgKiAgZWc6IEJhbmsgUiAoR2VybWFueSkgMSBvZiA2XG4gICovXG4gIEBJbnB1dCgpIGluZGV4QW5kTGVuZ3RoU2NyZWVuUmVhZGVyVGV4dCA9ICcgb2YgJztcblxuICAvKipcbiAgICAqIFdoZXRoZXIgb3Igbm90IHRoZSBzZWFyY2ggZmllbGQgc2hvdWxkIGJlIGNsZWFyZWQgYWZ0ZXIgdGhlIGRyb3Bkb3duIG1lbnUgaXMgY2xvc2VkLlxuICAgICogVXNlZnVsIGZvciBzZXJ2ZXItc2lkZSBmaWx0ZXJpbmcuIFNlZSBbIzNdKGh0dHBzOi8vZ2l0aHViLmNvbS9iaXRob3N0LWdtYmgvbmd4LW1hdC1zZWxlY3Qtc2VhcmNoL2lzc3Vlcy8zKVxuICAgICovXG4gIEBJbnB1dCgpIGNsZWFyU2VhcmNoSW5wdXQgPSB0cnVlO1xuXG4gIC8qKiBXaGV0aGVyIHRvIHNob3cgdGhlIHNlYXJjaC1pbi1wcm9ncmVzcyBpbmRpY2F0b3IgKi9cbiAgQElucHV0KCkgc2VhcmNoaW5nID0gZmFsc2U7XG5cbiAgLyoqIERpc2FibGVzIGluaXRpYWwgZm9jdXNpbmcgb2YgdGhlIGlucHV0IGZpZWxkICovXG4gIEBJbnB1dCgpIGRpc2FibGVJbml0aWFsRm9jdXMgPSBmYWxzZTtcblxuICAvKiogRW5hYmxlIGNsZWFyIGlucHV0IG9uIGVzY2FwZSBwcmVzc2VkICovXG4gIEBJbnB1dCgpIGVuYWJsZUNsZWFyT25Fc2NhcGVQcmVzc2VkID0gZmFsc2U7XG5cbiAgLyoqXG4gICAqIFByZXZlbnRzIGhvbWUgLyBlbmQga2V5IGJlaW5nIHByb3BhZ2F0ZWQgdG8gbWF0LXNlbGVjdCxcbiAgICogYWxsb3dpbmcgdG8gbW92ZSB0aGUgY3Vyc29yIHdpdGhpbiB0aGUgc2VhcmNoIGlucHV0IGluc3RlYWQgb2YgbmF2aWdhdGluZyB0aGUgb3B0aW9uc1xuICAgKi9cbiAgQElucHV0KCkgcHJldmVudEhvbWVFbmRLZXlQcm9wYWdhdGlvbiA9IGZhbHNlO1xuXG4gIC8qKiBEaXNhYmxlcyBzY3JvbGxpbmcgdG8gYWN0aXZlIG9wdGlvbnMgd2hlbiBvcHRpb24gbGlzdCBjaGFuZ2VzLiBVc2VmdWwgZm9yIHNlcnZlci1zaWRlIHNlYXJjaCAqL1xuICBASW5wdXQoKSBkaXNhYmxlU2Nyb2xsVG9BY3RpdmVPbk9wdGlvbnNDaGFuZ2VkID0gZmFsc2U7XG5cbiAgLyoqIEFkZHMgNTA4IHNjcmVlbiByZWFkZXIgc3VwcG9ydCBmb3Igc2VhcmNoIGJveCAqL1xuICBASW5wdXQoKSBhcmlhTGFiZWwgPSAnZHJvcGRvd24gc2VhcmNoJztcblxuICAvKiogV2hldGhlciB0byBzaG93IFNlbGVjdCBBbGwgQ2hlY2tib3ggKGZvciBtYXQtc2VsZWN0W211bHRpPXRydWVdKSAqL1xuICBASW5wdXQoKSBzaG93VG9nZ2xlQWxsQ2hlY2tib3ggPSBmYWxzZTtcblxuICAvKiogc2VsZWN0IGFsbCBjaGVja2JveCBjaGVja2VkIHN0YXRlICovXG4gIEBJbnB1dCgpIHRvZ2dsZUFsbENoZWNrYm94Q2hlY2tlZCA9IGZhbHNlO1xuXG4gIC8qKiBzZWxlY3QgYWxsIGNoZWNrYm94IGluZGV0ZXJtaW5hdGUgc3RhdGUgKi9cbiAgQElucHV0KCkgdG9nZ2xlQWxsQ2hlY2tib3hJbmRldGVybWluYXRlID0gZmFsc2U7XG5cbiAgLyoqIERpc3BsYXkgYSBtZXNzYWdlIGluIGEgdG9vbHRpcCBvbiB0aGUgdG9nZ2xlLWFsbCBjaGVja2JveCAqL1xuICBASW5wdXQoKSB0b2dnbGVBbGxDaGVja2JveFRvb2x0aXBNZXNzYWdlID0gJyc7XG5cbiAgLyoqIERlZmluZSB0aGUgcG9zaXRpb24gb2YgdGhlIHRvb2x0aXAgb24gdGhlIHRvZ2dsZS1hbGwgY2hlY2tib3guICovXG4gIEBJbnB1dCgpIHRvb2dsZUFsbENoZWNrYm94VG9vbHRpcFBvc2l0aW9uOiAnbGVmdCcgfCAncmlnaHQnIHwgJ2Fib3ZlJyB8ICdiZWxvdycgfCAnYmVmb3JlJyB8ICdhZnRlcicgPSAnYmVsb3cnO1xuXG4gIC8qKiBTaG93L0hpZGUgdGhlIHNlYXJjaCBjbGVhciBidXR0b24gb2YgdGhlIHNlYXJjaCBpbnB1dCAqL1xuICBASW5wdXQoKSBoaWRlQ2xlYXJTZWFyY2hCdXR0b24gPSBmYWxzZTtcblxuICAvKipcbiAgICogQWx3YXlzIHJlc3RvcmUgc2VsZWN0ZWQgb3B0aW9ucyBvbiBzZWxlY3Rpb25DaGFuZ2UgZm9yIG1vZGUgbXVsdGkgKGUuZy4gZm9yIGxhenkgbG9hZGluZy9pbmZpbml0eSBzY3JvbGxpbmcpLlxuICAgKiBEZWZhdWx0cyB0byBmYWxzZSwgc28gc2VsZWN0ZWQgb3B0aW9ucyBhcmUgb25seSByZXN0b3JlZCB3aGlsZSBmaWx0ZXJpbmcgaXMgYWN0aXZlLlxuICAgKi9cbiAgQElucHV0KCkgYWx3YXlzUmVzdG9yZVNlbGVjdGVkT3B0aW9uc011bHRpID0gZmFsc2U7XG5cbiAgLyoqIE91dHB1dCBlbWl0dGVyIHRvIHNlbmQgdG8gcGFyZW50IGNvbXBvbmVudCB3aXRoIHRoZSB0b2dnbGUgYWxsIGJvb2xlYW4gKi9cbiAgQE91dHB1dCgpIHRvZ2dsZUFsbCA9IG5ldyBFdmVudEVtaXR0ZXI8Ym9vbGVhbj4oKTtcblxuICAvKiogUmVmZXJlbmNlIHRvIHRoZSBzZWFyY2ggaW5wdXQgZmllbGQgKi9cbiAgQFZpZXdDaGlsZCgnc2VhcmNoU2VsZWN0SW5wdXQnLCB7IHJlYWQ6IEVsZW1lbnRSZWYsIHN0YXRpYzogdHJ1ZSB9KSBzZWFyY2hTZWxlY3RJbnB1dDogRWxlbWVudFJlZjtcblxuICAvKiogUmVmZXJlbmNlIHRvIHRoZSBzZWFyY2ggaW5wdXQgZmllbGQgKi9cbiAgQFZpZXdDaGlsZCgnaW5uZXJTZWxlY3RTZWFyY2gnLCB7IHJlYWQ6IEVsZW1lbnRSZWYsIHN0YXRpYzogdHJ1ZSB9KSBpbm5lclNlbGVjdFNlYXJjaDogRWxlbWVudFJlZjtcblxuICAvKiogUmVmZXJlbmNlIHRvIGN1c3RvbSBzZWFyY2ggaW5wdXQgY2xlYXIgaWNvbiAqL1xuICBAQ29udGVudENoaWxkKE1hdFNlbGVjdFNlYXJjaENsZWFyRGlyZWN0aXZlLCB7IHN0YXRpYzogZmFsc2UgfSkgY2xlYXJJY29uOiBNYXRTZWxlY3RTZWFyY2hDbGVhckRpcmVjdGl2ZTtcblxuICBASG9zdEJpbmRpbmcoJ2NsYXNzLm1hdC1zZWxlY3Qtc2VhcmNoLWluc2lkZS1tYXQtb3B0aW9uJylcbiAgZ2V0IGlzSW5zaWRlTWF0T3B0aW9uKCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiAhIXRoaXMubWF0T3B0aW9uO1xuICB9XG5cbiAgLyoqIEN1cnJlbnQgc2VhcmNoIHZhbHVlICovXG4gIGdldCB2YWx1ZSgpOiBzdHJpbmcge1xuICAgIHJldHVybiB0aGlzLl9mb3JtQ29udHJvbC52YWx1ZTtcbiAgfVxuICBwcml2YXRlIF9sYXN0RXh0ZXJuYWxJbnB1dFZhbHVlOiBzdHJpbmc7XG5cbiAgb25Ub3VjaGVkOiBGdW5jdGlvbiA9IChfOiBhbnkpID0+IHsgfTtcblxuICAvKiogUmVmZXJlbmNlIHRvIHRoZSBNYXRTZWxlY3Qgb3B0aW9ucyAqL1xuICBwdWJsaWMgc2V0IF9vcHRpb25zKF9vcHRpb25zOiBRdWVyeUxpc3Q8TWF0T3B0aW9uPikge1xuICAgIHRoaXMuX29wdGlvbnMkLm5leHQoX29wdGlvbnMpO1xuICB9XG4gIHB1YmxpYyBnZXQgX29wdGlvbnMoKTogUXVlcnlMaXN0PE1hdE9wdGlvbj4ge1xuICAgIHJldHVybiB0aGlzLl9vcHRpb25zJC5nZXRWYWx1ZSgpO1xuICB9XG4gIHB1YmxpYyBfb3B0aW9ucyQ6IEJlaGF2aW9yU3ViamVjdDxRdWVyeUxpc3Q8TWF0T3B0aW9uPj4gPSBuZXcgQmVoYXZpb3JTdWJqZWN0PFF1ZXJ5TGlzdDxNYXRPcHRpb24+PihudWxsKTtcblxuICBwcml2YXRlIG9wdGlvbnNMaXN0JDogT2JzZXJ2YWJsZTxNYXRPcHRpb25bXT4gPSB0aGlzLl9vcHRpb25zJC5waXBlKFxuICAgIHN3aXRjaE1hcChfb3B0aW9ucyA9PiBfb3B0aW9ucyA/XG4gICAgICBfb3B0aW9ucy5jaGFuZ2VzLnBpcGUoXG4gICAgICAgIG1hcChvcHRpb25zID0+IG9wdGlvbnMudG9BcnJheSgpKSxcbiAgICAgICAgc3RhcnRXaXRoPE1hdE9wdGlvbltdPihfb3B0aW9ucy50b0FycmF5KCkpLFxuICAgICAgKSA6IG9mKG51bGwpXG4gICAgKVxuICApO1xuXG4gIHByaXZhdGUgb3B0aW9uc0xlbmd0aCQ6IE9ic2VydmFibGU8bnVtYmVyPiA9IHRoaXMub3B0aW9uc0xpc3QkLnBpcGUoXG4gICAgbWFwKG9wdGlvbnMgPT4gb3B0aW9ucyA/IG9wdGlvbnMubGVuZ3RoIDogMClcbiAgKTtcblxuICAvKiogUHJldmlvdXNseSBzZWxlY3RlZCB2YWx1ZXMgd2hlbiB1c2luZyA8bWF0LXNlbGVjdCBbbXVsdGlwbGVdPVwidHJ1ZVwiPiovXG4gIHByaXZhdGUgcHJldmlvdXNTZWxlY3RlZFZhbHVlczogYW55W107XG5cbiAgcHVibGljIF9mb3JtQ29udHJvbDogRm9ybUNvbnRyb2wgPSBuZXcgRm9ybUNvbnRyb2woJycpO1xuXG4gIC8qKiB3aGV0aGVyIHRvIHNob3cgdGhlIG5vIGVudHJpZXMgZm91bmQgbWVzc2FnZSAqL1xuICBwdWJsaWMgX3Nob3dOb0VudHJpZXNGb3VuZCQ6IE9ic2VydmFibGU8Ym9vbGVhbj4gPSBjb21iaW5lTGF0ZXN0KFtcbiAgICB0aGlzLl9mb3JtQ29udHJvbC52YWx1ZUNoYW5nZXMsXG4gICAgdGhpcy5vcHRpb25zTGVuZ3RoJFxuICBdKS5waXBlKFxuICAgIG1hcCgoW3ZhbHVlLCBvcHRpb25zTGVuZ3RoXSkgPT4gdGhpcy5ub0VudHJpZXNGb3VuZExhYmVsICYmIHZhbHVlXG4gICAgICAmJiBvcHRpb25zTGVuZ3RoID09PSB0aGlzLmdldE9wdGlvbnNMZW5ndGhPZmZzZXQoKSlcbiAgKTtcblxuICAvKiogU3ViamVjdCB0aGF0IGVtaXRzIHdoZW4gdGhlIGNvbXBvbmVudCBoYXMgYmVlbiBkZXN0cm95ZWQuICovXG4gIHByaXZhdGUgX29uRGVzdHJveSA9IG5ldyBTdWJqZWN0PHZvaWQ+KCk7XG5cblxuICBjb25zdHJ1Y3RvcihASW5qZWN0KE1hdFNlbGVjdCkgcHVibGljIG1hdFNlbGVjdDogTWF0U2VsZWN0LFxuICAgIHB1YmxpYyBjaGFuZ2VEZXRlY3RvclJlZjogQ2hhbmdlRGV0ZWN0b3JSZWYsXG4gICAgcHJpdmF0ZSBfdmlld3BvcnRSdWxlcjogVmlld3BvcnRSdWxlcixcbiAgICBAT3B0aW9uYWwoKSBASW5qZWN0KE1hdE9wdGlvbikgcHVibGljIG1hdE9wdGlvbjogTWF0T3B0aW9uID0gbnVsbCxcbiAgICBwcml2YXRlIGxpdmVBbm5vdW5jZXI6IExpdmVBbm5vdW5jZXIsXG4gICAgQE9wdGlvbmFsKCkgQEluamVjdChNYXRGb3JtRmllbGQpIHB1YmxpYyBtYXRGb3JtRmllbGQ6IE1hdEZvcm1GaWVsZCA9IG51bGxcbiAgKSB7XG4gIH1cblxuICBuZ09uSW5pdCgpIHtcbiAgICAvLyBzZXQgY3VzdG9tIHBhbmVsIGNsYXNzXG4gICAgY29uc3QgcGFuZWxDbGFzcyA9ICdtYXQtc2VsZWN0LXNlYXJjaC1wYW5lbCc7XG4gICAgaWYgKHRoaXMubWF0U2VsZWN0LnBhbmVsQ2xhc3MpIHtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KHRoaXMubWF0U2VsZWN0LnBhbmVsQ2xhc3MpKSB7XG4gICAgICAgICg8c3RyaW5nW10+dGhpcy5tYXRTZWxlY3QucGFuZWxDbGFzcykucHVzaChwYW5lbENsYXNzKTtcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHRoaXMubWF0U2VsZWN0LnBhbmVsQ2xhc3MgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHRoaXMubWF0U2VsZWN0LnBhbmVsQ2xhc3MgPSBbdGhpcy5tYXRTZWxlY3QucGFuZWxDbGFzcywgcGFuZWxDbGFzc107XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiB0aGlzLm1hdFNlbGVjdC5wYW5lbENsYXNzID09PSAnb2JqZWN0Jykge1xuICAgICAgICB0aGlzLm1hdFNlbGVjdC5wYW5lbENsYXNzW3BhbmVsQ2xhc3NdID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5tYXRTZWxlY3QucGFuZWxDbGFzcyA9IHBhbmVsQ2xhc3M7XG4gICAgfVxuXG4gICAgLy8gc2V0IGN1c3RvbSBtYXQtb3B0aW9uIGNsYXNzIGlmIHRoZSBjb21wb25lbnQgd2FzIHBsYWNlZCBpbnNpZGUgYSBtYXQtb3B0aW9uXG4gICAgaWYgKHRoaXMubWF0T3B0aW9uKSB7XG4gICAgICB0aGlzLm1hdE9wdGlvbi5kaXNhYmxlZCA9IHRydWU7XG4gICAgICB0aGlzLm1hdE9wdGlvbi5fZ2V0SG9zdEVsZW1lbnQoKS5jbGFzc0xpc3QuYWRkKCdjb250YWlucy1tYXQtc2VsZWN0LXNlYXJjaCcpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zb2xlLmVycm9yKCc8bmd4LW1hdC1zZWxlY3Qtc2VhcmNoPiBtdXN0IGJlIHBsYWNlZCBpbnNpZGUgYSA8bWF0LW9wdGlvbj4gZWxlbWVudCcpO1xuICAgIH1cblxuICAgIC8vIHdoZW4gdGhlIHNlbGVjdCBkcm9wZG93biBwYW5lbCBpcyBvcGVuZWQgb3IgY2xvc2VkXG4gICAgdGhpcy5tYXRTZWxlY3Qub3BlbmVkQ2hhbmdlXG4gICAgICAucGlwZShcbiAgICAgICAgZGVsYXkoMSksXG4gICAgICAgIHRha2VVbnRpbCh0aGlzLl9vbkRlc3Ryb3kpXG4gICAgICApXG4gICAgICAuc3Vic2NyaWJlKChvcGVuZWQpID0+IHtcbiAgICAgICAgaWYgKG9wZW5lZCkge1xuICAgICAgICAgIHRoaXMudXBkYXRlSW5wdXRXaWR0aCgpO1xuICAgICAgICAgIC8vIGZvY3VzIHRoZSBzZWFyY2ggZmllbGQgd2hlbiBvcGVuaW5nXG4gICAgICAgICAgaWYgKCF0aGlzLmRpc2FibGVJbml0aWFsRm9jdXMpIHtcbiAgICAgICAgICAgIHRoaXMuX2ZvY3VzKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIGNsZWFyIGl0IHdoZW4gY2xvc2luZ1xuICAgICAgICAgIGlmICh0aGlzLmNsZWFyU2VhcmNoSW5wdXQpIHtcbiAgICAgICAgICAgIHRoaXMuX3Jlc2V0KCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcblxuXG5cbiAgICAvLyBzZXQgdGhlIGZpcnN0IGl0ZW0gYWN0aXZlIGFmdGVyIHRoZSBvcHRpb25zIGNoYW5nZWRcbiAgICB0aGlzLm1hdFNlbGVjdC5vcGVuZWRDaGFuZ2VcbiAgICAgIC5waXBlKHRha2UoMSkpXG4gICAgICAucGlwZSh0YWtlVW50aWwodGhpcy5fb25EZXN0cm95KSlcbiAgICAgIC5zdWJzY3JpYmUoKCkgPT4ge1xuICAgICAgICBpZiAodGhpcy5tYXRTZWxlY3QuX2tleU1hbmFnZXIpIHtcbiAgICAgICAgICB0aGlzLm1hdFNlbGVjdC5fa2V5TWFuYWdlci5jaGFuZ2UucGlwZSh0YWtlVW50aWwodGhpcy5fb25EZXN0cm95KSlcbiAgICAgICAgICAgIC5zdWJzY3JpYmUoKCkgPT4gdGhpcy5hZGp1c3RTY3JvbGxUb3BUb0ZpdEFjdGl2ZU9wdGlvbkludG9WaWV3KCkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnNvbGUubG9nKCdfa2V5TWFuYWdlciB3YXMgbm90IGluaXRpYWxpemVkLicpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fb3B0aW9ucyA9IHRoaXMubWF0U2VsZWN0Lm9wdGlvbnM7XG5cbiAgICAgICAgLy8gQ2xvc3VyZSB2YXJpYWJsZSBmb3IgdHJhY2tpbmcgdGhlIG1vc3QgcmVjZW50IGZpcnN0IG9wdGlvbi5cbiAgICAgICAgLy8gSW4gb3JkZXIgdG8gYXZvaWQgYXZvaWQgY2F1c2luZyB0aGUgbGlzdCB0b1xuICAgICAgICAvLyBzY3JvbGwgdG8gdGhlIHRvcCB3aGVuIG9wdGlvbnMgYXJlIGFkZGVkIHRvIHRoZSBib3R0b20gb2ZcbiAgICAgICAgLy8gdGhlIGxpc3QgKGVnOiBpbmZpbml0ZSBzY3JvbGwpLCB3ZSBjb21wYXJlIG9ubHlcbiAgICAgICAgLy8gdGhlIGNoYW5nZXMgdG8gdGhlIGZpcnN0IG9wdGlvbnMgdG8gZGV0ZXJtaW5lIGlmIHdlXG4gICAgICAgIC8vIHNob3VsZCBzZXQgdGhlIGZpcnN0IGl0ZW0gYXMgYWN0aXZlLlxuICAgICAgICAvLyBUaGlzIHByZXZlbnRzIHVubmVjZXNzYXJ5IHNjcm9sbGluZyB0byB0aGUgdG9wIG9mIHRoZSBsaXN0XG4gICAgICAgIC8vIHdoZW4gb3B0aW9ucyBhcmUgYXBwZW5kZWQsIGJ1dCBhbGxvd3MgdGhlIGZpcnN0IGl0ZW1cbiAgICAgICAgLy8gaW4gdGhlIGxpc3QgdG8gYmUgc2V0IGFzIGFjdGl2ZSBieSBkZWZhdWx0IHdoZW4gdGhlcmVcbiAgICAgICAgLy8gaXMgbm8gYWN0aXZlIHNlbGVjdGlvblxuICAgICAgICBsZXQgcHJldmlvdXNGaXJzdE9wdGlvbiA9IHRoaXMuX29wdGlvbnMudG9BcnJheSgpW3RoaXMuZ2V0T3B0aW9uc0xlbmd0aE9mZnNldCgpXTtcblxuICAgICAgICB0aGlzLl9vcHRpb25zLmNoYW5nZXNcbiAgICAgICAgICAucGlwZShcbiAgICAgICAgICAgIHRha2VVbnRpbCh0aGlzLl9vbkRlc3Ryb3kpXG4gICAgICAgICAgKVxuICAgICAgICAgIC5zdWJzY3JpYmUoKCkgPT4ge1xuICAgICAgICAgICAgLy8gYXZvaWQgXCJleHByZXNzaW9uIGhhcyBiZWVuIGNoYW5nZWRcIiBlcnJvclxuICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgIC8vIENvbnZlcnQgdGhlIFF1ZXJ5TGlzdCB0byBhbiBhcnJheVxuICAgICAgICAgICAgICBjb25zdCBvcHRpb25zID0gdGhpcy5fb3B0aW9ucy50b0FycmF5KCk7XG5cbiAgICAgICAgICAgICAgLy8gVGhlIHRydWUgZmlyc3QgaXRlbSBpcyBvZmZzZXQgYnkgMVxuICAgICAgICAgICAgICBjb25zdCBjdXJyZW50Rmlyc3RPcHRpb24gPSBvcHRpb25zW3RoaXMuZ2V0T3B0aW9uc0xlbmd0aE9mZnNldCgpXTtcblxuICAgICAgICAgICAgICBjb25zdCBrZXlNYW5hZ2VyID0gdGhpcy5tYXRTZWxlY3QuX2tleU1hbmFnZXI7XG4gICAgICAgICAgICAgIGlmIChrZXlNYW5hZ2VyICYmIHRoaXMubWF0U2VsZWN0LnBhbmVsT3Blbikge1xuXG4gICAgICAgICAgICAgICAgLy8gc2V0IGZpcnN0IGl0ZW0gYWN0aXZlIGFuZCBpbnB1dCB3aWR0aFxuXG4gICAgICAgICAgICAgICAgLy8gQ2hlY2sgdG8gc2VlIGlmIHRoZSBmaXJzdCBvcHRpb24gaW4gdGhlc2UgY2hhbmdlcyBpcyBkaWZmZXJlbnQgZnJvbSB0aGUgcHJldmlvdXMuXG4gICAgICAgICAgICAgICAgY29uc3QgZmlyc3RPcHRpb25Jc0NoYW5nZWQgPSAhdGhpcy5tYXRTZWxlY3QuY29tcGFyZVdpdGgocHJldmlvdXNGaXJzdE9wdGlvbiwgY3VycmVudEZpcnN0T3B0aW9uKTtcblxuICAgICAgICAgICAgICAgIC8vIENBU0U6IFRoZSBmaXJzdCBvcHRpb24gaXMgZGlmZmVyZW50IG5vdy5cbiAgICAgICAgICAgICAgICAvLyBJbmRpY2lhdGVzIHdlIHNob3VsZCBzZXQgaXQgYXMgYWN0aXZlIGFuZCBzY3JvbGwgdG8gdGhlIHRvcC5cbiAgICAgICAgICAgICAgICBpZiAoZmlyc3RPcHRpb25Jc0NoYW5nZWRcbiAgICAgICAgICAgICAgICAgIHx8ICFrZXlNYW5hZ2VyLmFjdGl2ZUl0ZW1cbiAgICAgICAgICAgICAgICAgIHx8ICFvcHRpb25zLmZpbmQob3B0aW9uID0+IHRoaXMubWF0U2VsZWN0LmNvbXBhcmVXaXRoKG9wdGlvbiwga2V5TWFuYWdlci5hY3RpdmVJdGVtKSkpIHtcbiAgICAgICAgICAgICAgICAgIGtleU1hbmFnZXIuc2V0Rmlyc3RJdGVtQWN0aXZlKCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gd2FpdCBmb3IgcGFuZWwgd2lkdGggY2hhbmdlc1xuICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgdGhpcy51cGRhdGVJbnB1dFdpZHRoKCk7XG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuZGlzYWJsZVNjcm9sbFRvQWN0aXZlT25PcHRpb25zQ2hhbmdlZCkge1xuICAgICAgICAgICAgICAgICAgdGhpcy5hZGp1c3RTY3JvbGxUb3BUb0ZpdEFjdGl2ZU9wdGlvbkludG9WaWV3KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgLy8gVXBkYXRlIG91ciByZWZlcmVuY2VcbiAgICAgICAgICAgICAgcHJldmlvdXNGaXJzdE9wdGlvbiA9IGN1cnJlbnRGaXJzdE9wdGlvbjtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0pO1xuICAgICAgfSk7XG5cbiAgICAvLyBhZGQgb3IgcmVtb3ZlIGNzcyBjbGFzcyBkZXBlbmRpbmcgb24gd2hldGhlciB0byBzaG93IHRoZSBubyBlbnRyaWVzIGZvdW5kIG1lc3NhZ2VcbiAgICAvLyBub3RlOiB0aGlzIGlzIGhhY2t5XG4gICAgdGhpcy5fc2hvd05vRW50cmllc0ZvdW5kJC5waXBlKFxuICAgICAgdGFrZVVudGlsKHRoaXMuX29uRGVzdHJveSlcbiAgICApLnN1YnNjcmliZShzaG93Tm9FbnRyaWVzRm91bmQgPT4ge1xuICAgICAgLy8gc2V0IG5vIGVudHJpZXMgZm91bmQgY2xhc3Mgb24gbWF0IG9wdGlvblxuICAgICAgaWYgKHRoaXMubWF0T3B0aW9uKSB7XG4gICAgICAgIGlmIChzaG93Tm9FbnRyaWVzRm91bmQpIHtcbiAgICAgICAgICB0aGlzLm1hdE9wdGlvbi5fZ2V0SG9zdEVsZW1lbnQoKS5jbGFzc0xpc3QuYWRkKCdtYXQtc2VsZWN0LXNlYXJjaC1uby1lbnRyaWVzLWZvdW5kJyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5tYXRPcHRpb24uX2dldEhvc3RFbGVtZW50KCkuY2xhc3NMaXN0LnJlbW92ZSgnbWF0LXNlbGVjdC1zZWFyY2gtbm8tZW50cmllcy1mb3VuZCcpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICAvLyByZXNpemUgdGhlIGlucHV0IHdpZHRoIHdoZW4gdGhlIHZpZXdwb3J0IGlzIHJlc2l6ZWQsIGkuZS4gdGhlIHRyaWdnZXIgd2lkdGggY291bGQgcG90ZW50aWFsbHkgYmUgcmVzaXplZFxuICAgIHRoaXMuX3ZpZXdwb3J0UnVsZXIuY2hhbmdlKClcbiAgICAgIC5waXBlKHRha2VVbnRpbCh0aGlzLl9vbkRlc3Ryb3kpKVxuICAgICAgLnN1YnNjcmliZSgoKSA9PiB7XG4gICAgICAgIGlmICh0aGlzLm1hdFNlbGVjdC5wYW5lbE9wZW4pIHtcbiAgICAgICAgICB0aGlzLnVwZGF0ZUlucHV0V2lkdGgoKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICB0aGlzLmluaXRNdWx0aXBsZUhhbmRsaW5nKCk7XG5cbiAgICB0aGlzLm9wdGlvbnNMaXN0JC5waXBlKFxuICAgICAgdGFrZVVudGlsKHRoaXMuX29uRGVzdHJveSlcbiAgICApLnN1YnNjcmliZSgoKSA9PiB7XG4gICAgICAvLyB1cGRhdGUgdmlldyB3aGVuIGF2YWlsYWJsZSBvcHRpb25zIGNoYW5nZVxuICAgICAgdGhpcy5jaGFuZ2VEZXRlY3RvclJlZi5tYXJrRm9yQ2hlY2soKTtcbiAgICB9KTtcbiAgfVxuXG4gIF9lbWl0U2VsZWN0QWxsQm9vbGVhblRvUGFyZW50KHN0YXRlOiBib29sZWFuKSB7XG4gICAgdGhpcy50b2dnbGVBbGwuZW1pdChzdGF0ZSk7XG4gIH1cblxuICBuZ09uRGVzdHJveSgpIHtcbiAgICB0aGlzLl9vbkRlc3Ryb3kubmV4dCgpO1xuICAgIHRoaXMuX29uRGVzdHJveS5jb21wbGV0ZSgpO1xuICB9XG5cbiAgX2lzVG9nZ2xlQWxsQ2hlY2tib3hWaXNpYmxlKCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLm1hdFNlbGVjdC5tdWx0aXBsZSAmJiB0aGlzLnNob3dUb2dnbGVBbGxDaGVja2JveDtcbiAgfVxuXG4gIC8qKlxuICAgKiBIYW5kbGVzIHRoZSBrZXkgZG93biBldmVudCB3aXRoIE1hdFNlbGVjdC5cbiAgICogQWxsb3dzIGUuZy4gc2VsZWN0aW5nIHdpdGggZW50ZXIga2V5LCBuYXZpZ2F0aW9uIHdpdGggYXJyb3cga2V5cywgZXRjLlxuICAgKiBAcGFyYW0gZXZlbnRcbiAgICovXG4gIF9oYW5kbGVLZXlkb3duKGV2ZW50OiBLZXlib2FyZEV2ZW50KSB7XG4gICAgLy8gUHJldmVudCBwcm9wYWdhdGlvbiBmb3IgYWxsIGFscGhhbnVtZXJpYyBjaGFyYWN0ZXJzIGluIG9yZGVyIHRvIGF2b2lkIHNlbGVjdGlvbiBpc3N1ZXNcbiAgICBpZiAoKGV2ZW50LmtleSAmJiBldmVudC5rZXkubGVuZ3RoID09PSAxKSB8fFxuICAgICAgKGV2ZW50LmtleUNvZGUgPj0gQSAmJiBldmVudC5rZXlDb2RlIDw9IFopIHx8XG4gICAgICAoZXZlbnQua2V5Q29kZSA+PSBaRVJPICYmIGV2ZW50LmtleUNvZGUgPD0gTklORSkgfHxcbiAgICAgIChldmVudC5rZXlDb2RlID09PSBTUEFDRSlcbiAgICAgIHx8ICh0aGlzLnByZXZlbnRIb21lRW5kS2V5UHJvcGFnYXRpb24gJiYgKGV2ZW50LmtleUNvZGUgPT09IEhPTUUgfHwgZXZlbnQua2V5Q29kZSA9PT0gRU5EKSlcbiAgICApIHtcbiAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLm1hdFNlbGVjdC5tdWx0aXBsZSAmJiBldmVudC5rZXkgJiYgZXZlbnQua2V5Q29kZSA9PT0gRU5URVIpIHtcbiAgICAgIC8vIFJlZ2FpbiBmb2N1cyBhZnRlciBtdWx0aXNlbGVjdCwgc28gd2UgY2FuIGZ1cnRoZXIgdHlwZVxuICAgICAgc2V0VGltZW91dCgoKSA9PiB0aGlzLl9mb2N1cygpKTtcbiAgICB9XG5cbiAgICAvLyBTcGVjaWFsIGNhc2UgaWYgY2xpY2sgRXNjYXBlLCBpZiBpbnB1dCBpcyBlbXB0eSwgY2xvc2UgdGhlIGRyb3Bkb3duLCBpZiBub3QsIGVtcHR5IG91dCB0aGUgc2VhcmNoIGZpZWxkXG4gICAgaWYgKHRoaXMuZW5hYmxlQ2xlYXJPbkVzY2FwZVByZXNzZWQgPT09IHRydWUgJiYgZXZlbnQua2V5Q29kZSA9PT0gRVNDQVBFICYmIHRoaXMudmFsdWUpIHtcbiAgICAgIHRoaXMuX3Jlc2V0KHRydWUpO1xuICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEhhbmRsZXMgdGhlIGtleSB1cCBldmVudCB3aXRoIE1hdFNlbGVjdC5cbiAgICogQWxsb3dzIGUuZy4gdGhlIGFubm91bmNpbmcgb2YgdGhlIGN1cnJlbnRseSBhY3RpdmVEZXNjZW5kYW50IGJ5IHNjcmVlbiByZWFkZXJzLlxuICAgKi9cbiAgX2hhbmRsZUtleXVwKGV2ZW50OiBLZXlib2FyZEV2ZW50KSB7XG4gICAgaWYgKGV2ZW50LmtleUNvZGUgPT09IFVQX0FSUk9XIHx8IGV2ZW50LmtleUNvZGUgPT09IERPV05fQVJST1cpIHtcbiAgICAgIGNvbnN0IGFyaWFBY3RpdmVEZXNjZW5kYW50SWQgPSB0aGlzLm1hdFNlbGVjdC5fZ2V0QXJpYUFjdGl2ZURlc2NlbmRhbnQoKTtcbiAgICAgIGNvbnN0IGluZGV4ID0gdGhpcy5fb3B0aW9ucy50b0FycmF5KCkuZmluZEluZGV4KGl0ZW0gPT4gaXRlbS5pZCA9PT0gYXJpYUFjdGl2ZURlc2NlbmRhbnRJZCk7XG4gICAgICBpZiAoaW5kZXggIT09IC0xKSB7XG4gICAgICAgIGNvbnN0IGFjdGl2ZURlc2NlbmRhbnQgPSB0aGlzLl9vcHRpb25zLnRvQXJyYXkoKVtpbmRleF07XG4gICAgICAgIHRoaXMubGl2ZUFubm91bmNlci5hbm5vdW5jZShcbiAgICAgICAgICBhY3RpdmVEZXNjZW5kYW50LnZpZXdWYWx1ZSArICcgJ1xuICAgICAgICAgICsgdGhpcy5nZXRBcmlhSW5kZXgoaW5kZXgpXG4gICAgICAgICAgKyB0aGlzLmluZGV4QW5kTGVuZ3RoU2NyZWVuUmVhZGVyVGV4dFxuICAgICAgICAgICsgdGhpcy5nZXRBcmlhTGVuZ3RoKClcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ2FsY3VsYXRlIHRoZSBpbmRleCBvZiB0aGUgY3VycmVudCBvcHRpb24sIHRha2luZyB0aGUgb2Zmc2V0IHRvIGxlbmd0aCBpbnRvIGFjY291bnQuXG4gICAqIGV4YW1wbGVzOlxuICAgKiAgICBDYXNlIDEgW1NlYXJjaCwgMSwgMiwgM10gd2lsbCBoYXZlIG9mZnNldCBvZiAxLCBkdWUgdG8gc2VhcmNoIGFuZCB3aWxsIHJlYWQgaW5kZXggb2YgdG90YWwuXG4gICAqICAgIENhc2UgMiBbMSwgMiwgM10gd2lsbCBoYXZlIG9mZnNldCBvZiAwIGFuZCB3aWxsIHJlYWQgaW5kZXggKzEgb2YgdG90YWwuXG4gICAqL1xuICBnZXRBcmlhSW5kZXgob3B0aW9uSW5kZXg6IG51bWJlcik6IG51bWJlciB7XG4gICAgaWYgKHRoaXMuZ2V0T3B0aW9uc0xlbmd0aE9mZnNldCgpID09PSAwKSB7XG4gICAgICByZXR1cm4gb3B0aW9uSW5kZXggKyAxO1xuICAgIH1cbiAgICByZXR1cm4gb3B0aW9uSW5kZXg7XG4gIH1cblxuICAvKipcbiAgICogQ2FsY3VsYXRlIHRoZSBsZW5ndGggb2YgdGhlIG9wdGlvbnMsIHRha2luZyB0aGUgb2Zmc2V0IHRvIGxlbmd0aCBpbnRvIGFjY291bnQuXG4gICAqIGV4YW1wbGVzOlxuICAgKiAgICBDYXNlIDEgW1NlYXJjaCwgMSwgMiwgM10gd2lsbCBoYXZlIGxlbmd0aCBvZiBvcHRpb25zLmxlbmd0aCAtMSwgZHVlIHRvIHNlYXJjaC5cbiAgICogICAgQ2FzZSAyIFsxLCAyLCAzXSB3aWxsIGhhdmUgbGVuZ3RoIG9mIG9wdGlvbnMubGVuZ3RoLlxuICAgKi9cbiAgZ2V0QXJpYUxlbmd0aCgpOiBudW1iZXIge1xuICAgIHJldHVybiB0aGlzLl9vcHRpb25zLnRvQXJyYXkoKS5sZW5ndGggLSB0aGlzLmdldE9wdGlvbnNMZW5ndGhPZmZzZXQoKTtcbiAgfVxuXG4gIHdyaXRlVmFsdWUodmFsdWU6IHN0cmluZykge1xuICAgIHRoaXMuX2xhc3RFeHRlcm5hbElucHV0VmFsdWUgPSB2YWx1ZTtcbiAgICB0aGlzLl9mb3JtQ29udHJvbC5zZXRWYWx1ZSh2YWx1ZSk7XG4gICAgdGhpcy5jaGFuZ2VEZXRlY3RvclJlZi5tYXJrRm9yQ2hlY2soKTtcbiAgfVxuXG4gIG9uQmx1cigpIHtcbiAgICB0aGlzLm9uVG91Y2hlZCgpO1xuICB9XG5cbiAgcmVnaXN0ZXJPbkNoYW5nZShmbjogKHZhbHVlOiBzdHJpbmcpID0+IHZvaWQpIHtcbiAgICB0aGlzLl9mb3JtQ29udHJvbC52YWx1ZUNoYW5nZXMucGlwZShcbiAgICAgIGZpbHRlcih2YWx1ZSA9PiB2YWx1ZSAhPT0gdGhpcy5fbGFzdEV4dGVybmFsSW5wdXRWYWx1ZSksXG4gICAgICB0YXAoKCkgPT4gdGhpcy5fbGFzdEV4dGVybmFsSW5wdXRWYWx1ZSA9IHVuZGVmaW5lZCksXG4gICAgICB0YWtlVW50aWwodGhpcy5fb25EZXN0cm95KVxuICAgICkuc3Vic2NyaWJlKGZuKTtcbiAgfVxuXG4gIHJlZ2lzdGVyT25Ub3VjaGVkKGZuOiBGdW5jdGlvbikge1xuICAgIHRoaXMub25Ub3VjaGVkID0gZm47XG4gIH1cblxuICAvKipcbiAgICogRm9jdXNlcyB0aGUgc2VhcmNoIGlucHV0IGZpZWxkXG4gICAqL1xuICBwdWJsaWMgX2ZvY3VzKCkge1xuICAgIGlmICghdGhpcy5zZWFyY2hTZWxlY3RJbnB1dCB8fCAhdGhpcy5tYXRTZWxlY3QucGFuZWwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgLy8gc2F2ZSBhbmQgcmVzdG9yZSBzY3JvbGxUb3Agb2YgcGFuZWwsIHNpbmNlIGl0IHdpbGwgYmUgcmVzZXQgYnkgZm9jdXMoKVxuICAgIC8vIG5vdGU6IHRoaXMgaXMgaGFja3lcbiAgICBjb25zdCBwYW5lbCA9IHRoaXMubWF0U2VsZWN0LnBhbmVsLm5hdGl2ZUVsZW1lbnQ7XG4gICAgY29uc3Qgc2Nyb2xsVG9wID0gcGFuZWwuc2Nyb2xsVG9wO1xuXG4gICAgLy8gZm9jdXNcbiAgICB0aGlzLnNlYXJjaFNlbGVjdElucHV0Lm5hdGl2ZUVsZW1lbnQuZm9jdXMoKTtcblxuICAgIHBhbmVsLnNjcm9sbFRvcCA9IHNjcm9sbFRvcDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXNldHMgdGhlIGN1cnJlbnQgc2VhcmNoIHZhbHVlXG4gICAqIEBwYXJhbSBmb2N1cyB3aGV0aGVyIHRvIGZvY3VzIGFmdGVyIHJlc2V0dGluZ1xuICAgKi9cbiAgcHVibGljIF9yZXNldChmb2N1cz86IGJvb2xlYW4pIHtcbiAgICB0aGlzLl9mb3JtQ29udHJvbC5zZXRWYWx1ZSgnJyk7XG4gICAgaWYgKGZvY3VzKSB7XG4gICAgICB0aGlzLl9mb2N1cygpO1xuICAgIH1cbiAgfVxuXG5cbiAgLyoqXG4gICAqIEluaXRpYWxpemVzIGhhbmRsaW5nIDxtYXQtc2VsZWN0IFttdWx0aXBsZV09XCJ0cnVlXCI+XG4gICAqIE5vdGU6IHRvIGltcHJvdmUgdGhpcyBjb2RlLCBtYXQtc2VsZWN0IHNob3VsZCBiZSBleHRlbmRlZCB0byBhbGxvdyBkaXNhYmxpbmcgcmVzZXR0aW5nIHRoZSBzZWxlY3Rpb24gd2hpbGUgZmlsdGVyaW5nLlxuICAgKi9cbiAgcHJpdmF0ZSBpbml0TXVsdGlwbGVIYW5kbGluZygpIHtcbiAgICBpZiAoIXRoaXMubWF0U2VsZWN0Lm5nQ29udHJvbCkge1xuICAgICAgaWYgKHRoaXMubWF0U2VsZWN0Lm11bHRpcGxlKSB7XG4gICAgICAgIC8vIG5vdGU6IHRoZSBhY2Nlc3MgdG8gbWF0U2VsZWN0Lm5nQ29udHJvbCAoaW5zdGVhZCBvZiBtYXRTZWxlY3QudmFsdWUgLyBtYXRTZWxlY3QudmFsdWVDaGFuZ2VzKVxuICAgICAgICAvLyBpcyBuZWNlc3NhcnkgdG8gcHJvcGVybHkgd29yayBpbiBtdWx0aS1zZWxlY3Rpb24gbW9kZS5cbiAgICAgICAgY29uc29sZS5lcnJvcigndGhlIG1hdC1zZWxlY3QgY29udGFpbmluZyBuZ3gtbWF0LXNlbGVjdC1zZWFyY2ggbXVzdCBoYXZlIGEgbmdNb2RlbCBvciBmb3JtQ29udHJvbCBkaXJlY3RpdmUgd2hlbiBtdWx0aXBsZT10cnVlJyk7XG4gICAgICB9XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIC8vIGlmIDxtYXQtc2VsZWN0IFttdWx0aXBsZV09XCJ0cnVlXCI+XG4gICAgLy8gc3RvcmUgcHJldmlvdXNseSBzZWxlY3RlZCB2YWx1ZXMgYW5kIHJlc3RvcmUgdGhlbSB3aGVuIHRoZXkgYXJlIGRlc2VsZWN0ZWRcbiAgICAvLyBiZWNhdXNlIHRoZSBvcHRpb24gaXMgbm90IGF2YWlsYWJsZSB3aGlsZSB3ZSBhcmUgY3VycmVudGx5IGZpbHRlcmluZ1xuICAgIHRoaXMucHJldmlvdXNTZWxlY3RlZFZhbHVlcyA9IHRoaXMubWF0U2VsZWN0Lm5nQ29udHJvbC52YWx1ZTtcblxuICAgIHRoaXMubWF0U2VsZWN0Lm5nQ29udHJvbC52YWx1ZUNoYW5nZXNcbiAgICAgIC5waXBlKHRha2VVbnRpbCh0aGlzLl9vbkRlc3Ryb3kpKVxuICAgICAgLnN1YnNjcmliZSgodmFsdWVzKSA9PiB7XG4gICAgICAgIGxldCByZXN0b3JlU2VsZWN0ZWRWYWx1ZXMgPSBmYWxzZTtcbiAgICAgICAgaWYgKHRoaXMubWF0U2VsZWN0Lm11bHRpcGxlKSB7XG4gICAgICAgICAgaWYgKCh0aGlzLmFsd2F5c1Jlc3RvcmVTZWxlY3RlZE9wdGlvbnNNdWx0aSB8fCAodGhpcy5fZm9ybUNvbnRyb2wudmFsdWUgJiYgdGhpcy5fZm9ybUNvbnRyb2wudmFsdWUubGVuZ3RoKSlcbiAgICAgICAgICAgICYmIHRoaXMucHJldmlvdXNTZWxlY3RlZFZhbHVlcyAmJiBBcnJheS5pc0FycmF5KHRoaXMucHJldmlvdXNTZWxlY3RlZFZhbHVlcykpIHtcbiAgICAgICAgICAgIGlmICghdmFsdWVzIHx8ICFBcnJheS5pc0FycmF5KHZhbHVlcykpIHtcbiAgICAgICAgICAgICAgdmFsdWVzID0gW107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBvcHRpb25WYWx1ZXMgPSB0aGlzLm1hdFNlbGVjdC5vcHRpb25zLm1hcChvcHRpb24gPT4gb3B0aW9uLnZhbHVlKTtcbiAgICAgICAgICAgIHRoaXMucHJldmlvdXNTZWxlY3RlZFZhbHVlcy5mb3JFYWNoKHByZXZpb3VzVmFsdWUgPT4ge1xuICAgICAgICAgICAgICBpZiAoIXZhbHVlcy5zb21lKHYgPT4gdGhpcy5tYXRTZWxlY3QuY29tcGFyZVdpdGgodiwgcHJldmlvdXNWYWx1ZSkpXG4gICAgICAgICAgICAgICAgJiYgIW9wdGlvblZhbHVlcy5zb21lKHYgPT4gdGhpcy5tYXRTZWxlY3QuY29tcGFyZVdpdGgodiwgcHJldmlvdXNWYWx1ZSkpKSB7XG4gICAgICAgICAgICAgICAgLy8gaWYgYSB2YWx1ZSB0aGF0IHdhcyBzZWxlY3RlZCBiZWZvcmUgaXMgZGVzZWxlY3RlZCBhbmQgbm90IGZvdW5kIGluIHRoZSBvcHRpb25zLCBpdCB3YXMgZGVzZWxlY3RlZFxuICAgICAgICAgICAgICAgIC8vIGR1ZSB0byB0aGUgZmlsdGVyaW5nLCBzbyB3ZSByZXN0b3JlIGl0LlxuICAgICAgICAgICAgICAgIHZhbHVlcy5wdXNoKHByZXZpb3VzVmFsdWUpO1xuICAgICAgICAgICAgICAgIHJlc3RvcmVTZWxlY3RlZFZhbHVlcyA9IHRydWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLnByZXZpb3VzU2VsZWN0ZWRWYWx1ZXMgPSB2YWx1ZXM7XG5cbiAgICAgICAgaWYgKHJlc3RvcmVTZWxlY3RlZFZhbHVlcykge1xuICAgICAgICAgIHRoaXMubWF0U2VsZWN0Ll9vbkNoYW5nZSh2YWx1ZXMpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTY3JvbGxzIHRoZSBjdXJyZW50bHkgYWN0aXZlIG9wdGlvbiBpbnRvIHRoZSB2aWV3IGlmIGl0IGlzIG5vdCB5ZXQgdmlzaWJsZS5cbiAgICovXG4gIHByaXZhdGUgYWRqdXN0U2Nyb2xsVG9wVG9GaXRBY3RpdmVPcHRpb25JbnRvVmlldygpOiB2b2lkIHtcbiAgICBpZiAodGhpcy5tYXRTZWxlY3QucGFuZWwgJiYgdGhpcy5tYXRTZWxlY3Qub3B0aW9ucy5sZW5ndGggPiAwKSB7XG4gICAgICBjb25zdCBtYXRPcHRpb25IZWlnaHQgPSB0aGlzLmdldE1hdE9wdGlvbkhlaWdodCgpO1xuICAgICAgY29uc3QgYWN0aXZlT3B0aW9uSW5kZXggPSB0aGlzLm1hdFNlbGVjdC5fa2V5TWFuYWdlci5hY3RpdmVJdGVtSW5kZXggfHwgMDtcbiAgICAgIGNvbnN0IGxhYmVsQ291bnQgPSBfY291bnRHcm91cExhYmVsc0JlZm9yZU9wdGlvbihhY3RpdmVPcHRpb25JbmRleCwgdGhpcy5tYXRTZWxlY3Qub3B0aW9ucywgdGhpcy5tYXRTZWxlY3Qub3B0aW9uR3JvdXBzKTtcbiAgICAgIC8vIElmIHRoZSBjb21wb25lbnQgaXMgaW4gYSBNYXRPcHRpb24sIHRoZSBhY3RpdmVJdGVtSW5kZXggd2lsbCBiZSBvZmZzZXQgYnkgb25lLlxuICAgICAgY29uc3QgaW5kZXhPZk9wdGlvblRvRml0SW50b1ZpZXcgPSAodGhpcy5tYXRPcHRpb24gPyAtMSA6IDApICsgbGFiZWxDb3VudCArIGFjdGl2ZU9wdGlvbkluZGV4O1xuICAgICAgY29uc3QgY3VycmVudFNjcm9sbFRvcCA9IHRoaXMubWF0U2VsZWN0LnBhbmVsLm5hdGl2ZUVsZW1lbnQuc2Nyb2xsVG9wO1xuXG4gICAgICBjb25zdCBzZWFyY2hJbnB1dEhlaWdodCA9IHRoaXMuaW5uZXJTZWxlY3RTZWFyY2gubmF0aXZlRWxlbWVudC5vZmZzZXRIZWlnaHQ7XG4gICAgICBjb25zdCBhbW91bnRPZlZpc2libGVPcHRpb25zID0gTWF0aC5mbG9vcigoU0VMRUNUX1BBTkVMX01BWF9IRUlHSFQgLSBzZWFyY2hJbnB1dEhlaWdodCkgLyBtYXRPcHRpb25IZWlnaHQpO1xuXG4gICAgICBjb25zdCBpbmRleE9mRmlyc3RWaXNpYmxlT3B0aW9uID0gTWF0aC5yb3VuZCgoY3VycmVudFNjcm9sbFRvcCArIHNlYXJjaElucHV0SGVpZ2h0KSAvIG1hdE9wdGlvbkhlaWdodCkgLSAxO1xuXG4gICAgICBpZiAoaW5kZXhPZkZpcnN0VmlzaWJsZU9wdGlvbiA+PSBpbmRleE9mT3B0aW9uVG9GaXRJbnRvVmlldykge1xuICAgICAgICB0aGlzLm1hdFNlbGVjdC5wYW5lbC5uYXRpdmVFbGVtZW50LnNjcm9sbFRvcCA9IGluZGV4T2ZPcHRpb25Ub0ZpdEludG9WaWV3ICogbWF0T3B0aW9uSGVpZ2h0O1xuICAgICAgfSBlbHNlIGlmIChpbmRleE9mRmlyc3RWaXNpYmxlT3B0aW9uICsgYW1vdW50T2ZWaXNpYmxlT3B0aW9ucyA8PSBpbmRleE9mT3B0aW9uVG9GaXRJbnRvVmlldykge1xuICAgICAgICB0aGlzLm1hdFNlbGVjdC5wYW5lbC5uYXRpdmVFbGVtZW50LnNjcm9sbFRvcCA9IChpbmRleE9mT3B0aW9uVG9GaXRJbnRvVmlldyArIDEpICogbWF0T3B0aW9uSGVpZ2h0XG4gICAgICAgICAgLSAoU0VMRUNUX1BBTkVMX01BWF9IRUlHSFQgLSBzZWFyY2hJbnB1dEhlaWdodCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqICBTZXQgdGhlIHdpZHRoIG9mIHRoZSBpbm5lclNlbGVjdFNlYXJjaCB0byBmaXQgZXZlbiBjdXN0b20gc2Nyb2xsYmFyc1xuICAgKiAgQW5kIHN1cHBvcnQgYWxsIE9wZXJhdGlvbiBTeXN0ZW1zXG4gICAqL1xuICBwdWJsaWMgdXBkYXRlSW5wdXRXaWR0aCgpIHtcbiAgICBpZiAoIXRoaXMuaW5uZXJTZWxlY3RTZWFyY2ggfHwgIXRoaXMuaW5uZXJTZWxlY3RTZWFyY2gubmF0aXZlRWxlbWVudCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBsZXQgZWxlbWVudDogSFRNTEVsZW1lbnQgPSB0aGlzLmlubmVyU2VsZWN0U2VhcmNoLm5hdGl2ZUVsZW1lbnQ7XG4gICAgbGV0IHBhbmVsRWxlbWVudDogSFRNTEVsZW1lbnQ7XG4gICAgd2hpbGUgKGVsZW1lbnQgPSBlbGVtZW50LnBhcmVudEVsZW1lbnQpIHtcbiAgICAgIGlmIChlbGVtZW50LmNsYXNzTGlzdC5jb250YWlucygnbWF0LXNlbGVjdC1wYW5lbCcpKSB7XG4gICAgICAgIHBhbmVsRWxlbWVudCA9IGVsZW1lbnQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAocGFuZWxFbGVtZW50KSB7XG4gICAgICB0aGlzLmlubmVyU2VsZWN0U2VhcmNoLm5hdGl2ZUVsZW1lbnQuc3R5bGUud2lkdGggPSBwYW5lbEVsZW1lbnQuY2xpZW50V2lkdGggKyAncHgnO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgZ2V0TWF0T3B0aW9uSGVpZ2h0KCk6IG51bWJlciB7XG4gICAgaWYgKHRoaXMubWF0U2VsZWN0Lm9wdGlvbnMubGVuZ3RoID4gMCkge1xuICAgICAgcmV0dXJuIHRoaXMubWF0U2VsZWN0Lm9wdGlvbnMuZmlyc3QuX2dldEhvc3RFbGVtZW50KCkuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkuaGVpZ2h0O1xuICAgIH1cblxuICAgIHJldHVybiAwO1xuICB9XG5cbiAgLyoqXG4gICAqIERldGVybWluZSB0aGUgb2Zmc2V0IHRvIGxlbmd0aCB0aGF0IGNhbiBiZSBjYXVzZWQgYnkgdGhlIG9wdGlvbmFsIG1hdE9wdGlvbiB1c2VkIGFzIGEgc2VhcmNoIGlucHV0LlxuICAgKi9cbiAgcHJpdmF0ZSBnZXRPcHRpb25zTGVuZ3RoT2Zmc2V0KCk6IG51bWJlciB7XG4gICAgaWYgKHRoaXMubWF0T3B0aW9uKSB7XG4gICAgICByZXR1cm4gMTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICB9XG5cbn1cbiJdfQ==